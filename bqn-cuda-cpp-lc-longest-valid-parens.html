<!DOCTYPE html>
<html>
  <head>
    <title>BQN and CUDA C++ LeetCode Solutions – Asher Mancinelli – Mostly C++</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Solving a hard leetcode problem in the BQN APL dialect and CUDA C++!

">
    <meta property="og:description" content="Solving a hard leetcode problem in the BQN APL dialect and CUDA C++!

">
    
    <meta name="author" content="Asher Mancinelli">

    
    <meta property="og:title" content="BQN and CUDA C++ LeetCode Solutions">
    <meta property="twitter:title" content="BQN and CUDA C++ LeetCode Solutions">
    

    <link rel="icon" href="/images/chip.png">


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="alternate" type="application/rss+xml" title="Asher Mancinelli - Mostly C++" href="/feed.xml">

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/ashermancinelli/ashermancinelli.github.io/master/images/chip.png"></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Asher Mancinelli</a></h1>
            <p class="site-description">Mostly C++</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>BQN and CUDA C++ LeetCode Solutions</h1>

  <div class="entry">
    <p>Solving a hard leetcode problem in the BQN APL dialect and CUDA C++!</p>

<p><em>NOTE: This post is a transcript of <a href="https://youtu.be/3D7sfXzBBXE">the youtube video linked here</a>.</em></p>

<font size="-1">
  <em>
    These views do not in any way represent those of Pacific Northwest National Laboratory, the US Department of Energy, Battelle, or any other organization or institution that I, Asher Mancinelli, am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="problem">Problem</h2>

<p>Hello everyone, today I’d like to go through two solutions to a LeetCode problem.
We’ll first look at the solution with the BQN array language, and then we’ll look at a GPU-capable solution in CUDA that uses the Thrust template library.</p>

<p><a href="https://leetcode.com/problems/longest-valid-parentheses/">Link here</a>.</p>

<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid parentheses substring.</p>

<p>For example, for the string <code class="language-plaintext highlighter-rouge">")()())"</code> the expected answer is 4, and for this string the expected answer is two: <code class="language-plaintext highlighter-rouge">"())"</code>. Of course, for an empty string the answer is 0.</p>

<p>We’ll be looking at the solution in BQN first.</p>

<h2 id="bqnapl-solution">BQN/APL Solution</h2>

<p>Here is the full solution:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   F ← {0⌈1+⌈´⌈´¨∾¨1↓¨⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩}
   F ")()())"
4
   F "(()"
2
   F ""
0
</code></pre></div></div>

<p>I take the index into the string <code class="language-plaintext highlighter-rouge">")("</code> to convert to integers and I take all the prefixes of that array.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {↓")("⊸⊐ 𝕩} "(()"
⟨ ⟨ 1 1 0 ⟩ ⟨ 1 0 ⟩ ⟨ 0 ⟩ ⟨⟩ ⟩
</code></pre></div></div>

<p>I then multiply by two and subtract one so each index represents the change in the level of nesting at that index.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {1-˜¨2×¨↓")("⊸⊐ 𝕩} "(()"
⟨ ⟨ 1 1 ¯1 ⟩ ⟨ 1 ¯1 ⟩ ⟨ ¯1 ⟩ ⟨⟩ ⟩
</code></pre></div></div>

<p>I then plus-scan to find the cumulative level of nesting up to that index for each prefix of the array:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} "(()"
⟨ ⟨ 1 2 1 ⟩ ⟨ 1 0 ⟩ ⟨ ¯1 ⟩ ⟨⟩ ⟩
</code></pre></div></div>

<p>Find the zeros in each prefix, since these are the locations where the substring is balanced:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} "(()"
⟨ ⟨ 0 0 0 ⟩ ⟨ 0 1 ⟩ ⟨ 0 ⟩ ⟨⟩ ⟩
</code></pre></div></div>

<p>We can then group the results to find the indices which are nonbalanced and balanced for each prefix:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} "(()"
┌─                                            
· ⟨ ⟨ 0 1 2 ⟩ ⟩ ⟨ ⟨ 0 ⟩ ⟨ 1 ⟩ ⟩ ⟨ ⟨ 0 ⟩ ⟩ ⟨⟩  
                                             ┘
   {⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} ")()())" # Longer problem
┌─                                                                                                              
· ⟨ ⟨ 0 2 4 5 ⟩ ⟨ 1 3 ⟩ ⟩ ⟨ ⟨ 0 2 4 ⟩ ⟨ 1 3 ⟩ ⟩ ⟨ ⟨ 0 2 3 ⟩ ⟨ 1 ⟩ ⟩ ⟨ ⟨ 0 2 ⟩ ⟨ 1 ⟩ ⟩ ⟨ ⟨ 0 1 ⟩ ⟩ ⟨ ⟨ 0 ⟩ ⟩ ⟨⟩  
                                                                                                               ┘  
</code></pre></div></div>

<p>We can then of course drop the first list in each prefix so we only have the balanced indices. I’ll switch to the longer problem here so it’s a little easier to see what’s happening:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {1↓¨⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} ")()())"
┌─                                                      
· ⟨ ⟨ 1 3 ⟩ ⟩ ⟨ ⟨ 1 3 ⟩ ⟩ ⟨ ⟨ 1 ⟩ ⟩ ⟨ ⟨ 1 ⟩ ⟩ ⟨⟩ ⟨⟩ ⟨⟩  
                                                       ┘
</code></pre></div></div>

<p>We can then flatten the sublists together and find the largest element, which represents the index in a given prefix with the longest valid substring:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {⌈´⌈´¨∾¨1↓¨⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} ")()())"
3
</code></pre></div></div>

<p>Because we are using 0-based indices as God intended, we’ll have to add one to the result.
We’ll also take the maximum of our result and 0 in case no balanced substrings were found, which would otherwise give us <code class="language-plaintext highlighter-rouge">¯∞</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   {0⌈1+⌈´⌈´¨∾¨1↓¨⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩} ")()())"
4
</code></pre></div></div>

<p>Finally, let’s look at all the test cases:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   F ← {0⌈1+⌈´⌈´¨∾¨1↓¨⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩}
   F ")()())"
4
   F "(()"
2
   F ""
0
</code></pre></div></div>

<p>Now that we’ve gone through the BQN solution, let’s take a look at the CUDA and Thrust solution</p>

<h2 id="cudathrust-solution">CUDA/Thrust Solution</h2>

<p>Here is the full solution, minus some includes and using statements:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">solve</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">problem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">problem</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">host_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mapping</span><span class="p">;</span>
  <span class="n">mapping</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">problem</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">problem</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">mapping</span><span class="p">),</span>
                 <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
  <span class="n">device_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">starts</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">starts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">starts</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span>
      <span class="n">starts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">starts</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="n">d_mapping</span><span class="p">,</span> <span class="n">N</span><span class="p">](</span><span class="kt">int</span> <span class="n">max_so_far</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">device_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prefix</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
        <span class="n">thrust</span><span class="o">::</span><span class="n">inclusive_scan</span><span class="p">(</span><span class="n">d_mapping</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">d_mapping</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

        <span class="n">device_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">thrust</span><span class="o">::</span><span class="n">sequence</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">zip_start</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">make_zip_iterator</span><span class="p">(</span>
            <span class="n">thrust</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">()));</span>
        <span class="k">auto</span> <span class="n">zip_end</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">make_zip_iterator</span><span class="p">(</span>
            <span class="n">thrust</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>

        <span class="kt">int</span> <span class="n">max_for_prefix</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">transform_reduce</span><span class="p">(</span>
            <span class="n">zip_start</span><span class="p">,</span> <span class="n">zip_end</span><span class="p">,</span>
            <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">__device__</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">tup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">thrust</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">thrust</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_so_far</span><span class="p">,</span> <span class="n">max_for_prefix</span><span class="p">);</span>
      <span class="p">});</span>

  <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
<span class="err">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">problem</span> <span class="o">:</span> <span class="p">{</span> <span class="s">")()())"</span><span class="p">,</span> <span class="s">"(()"</span><span class="p">,</span> <span class="s">""</span> <span class="p">})</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">solve</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is quite a lot to take in, so let’s break it down.</p>

<p>First I grab the problem size so I don’t have to keep repeating myself, and I check to make sure our problem size is greater than zero.
I then transform the string into integers and copy the data to the GPU device.
This step is just like the bqn solution up until this point.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">problem</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">host_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mapping</span><span class="p">;</span>
  <span class="n">mapping</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">problem</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">problem</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">mapping</span><span class="p">),</span>
                 <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
  <span class="n">device_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
</code></pre></div></div>
<p>In BQN:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1-˜¨2×¨↓")("⊸⊐ 𝕩}
</code></pre></div></div>

<p>I then create an STL vector to hold the starting positions for each prefix.
I’m using the STL here instead of Thrust because I’ll otherwise have to nest my CUDA calls, and not all of the Thrust API is callable on the GPU device.
Ideally, we fit as much of our algorithm onto the GPU device to minimize any data transfer between memory spaces, but I still ended up using a mixture of the STL and Thrust.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">starts</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">starts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">starts</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Because of how the stl algorithms are used, we have to now go to the end of our
BQN solution. This call to accumulate corresponds to our outter reduction in our BQN solution here:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// BQN) F ← {0⌈1+⌈´⌈´¨∾¨1↓¨⊔¨0=+`¨1-˜¨2×¨↓")("⊸⊐ 𝕩}</span>
  <span class="c1">//               ^</span>
  <span class="c1">//              here</span>

  <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span>
      <span class="n">starts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">starts</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="n">d_mapping</span><span class="p">,</span> <span class="n">N</span><span class="p">](</span><span class="kt">int</span> <span class="n">max_so_far</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
      <span class="p">});</span>
</code></pre></div></div>

<p>We’re reducing over the maximum balanced substring for each prefix of the input string.</p>

<p>Next I create a device vector for the given prefix, and take the prefix sum of the current prefix.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// BQN) +`</span>
  <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(...</span>
        <span class="n">device_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prefix</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
        <span class="n">thrust</span><span class="o">::</span><span class="n">inclusive_scan</span><span class="p">(</span><span class="n">d_mapping</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">d_mapping</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</code></pre></div></div>

<p>I then create an <em>iota</em> to zip with our prefix-summed substring (or a <em>range</em> in BQN parlance, or a <em>sequence</em> in Thrust parlance (can’t we all just agree on a term here…)):</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">device_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">thrust</span><span class="o">::</span><span class="n">sequence</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">zip_start</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">make_zip_iterator</span><span class="p">(</span>
            <span class="n">thrust</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">()));</span>
        <span class="k">auto</span> <span class="n">zip_end</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">make_zip_iterator</span><span class="p">(</span>
            <span class="n">thrust</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>        
</code></pre></div></div>

<p>This corresponds to the <em>couple</em> dyad in BQN or the <em>zip</em> function in Python and lots of functional languages.</p>

<p>I then perform two algorithms in this one step. If the given position in the prefix-summed substring is zero, that means it’s balanced and I want to keep the index.
Otherwise, I can just throw it out.
After performing this transform or map algorithm, I take the max reduction of the substring to find the greatest index at which the substring is balanced.
If there are multiple points in the substring where the parens are balanced, this will find the greatest one.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="kt">int</span> <span class="n">max_for_prefix</span> <span class="o">=</span> <span class="n">thrust</span><span class="o">::</span><span class="n">transform_reduce</span><span class="p">(</span>
            <span class="n">zip_start</span><span class="p">,</span> <span class="n">zip_end</span><span class="p">,</span>
            <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">__device__</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">tup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">thrust</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">thrust</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">thrust</span><span class="o">::</span><span class="n">maximum</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></div></div>

<p>I then return the maximum balanced substring for the current prefix, which is then folded in the outter <code class="language-plaintext highlighter-rouge">std::accumulate</code> to find the greatest balanced substring for all prefixes in the original string.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(...</span>
        <span class="p">[...](</span><span class="kt">int</span> <span class="n">max_so_far</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">max_for_prefix</span> <span class="o">=</span> <span class="p">...</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_so_far</span><span class="p">,</span> <span class="n">max_for_prefix</span><span class="p">);</span>
        <span class="p">});</span>
</code></pre></div></div>

<p>I then return the maximum length I found, and we have our answer!</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">solve</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">problem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(...);</span>
  <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p>I ran this with the same test cases like so:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">problem</span> <span class="o">:</span> <span class="p">{</span> <span class="s">")()())"</span><span class="p">,</span> <span class="s">"(()"</span><span class="p">,</span> <span class="s">""</span> <span class="p">})</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">solve</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And running gave me:</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>./src/thrust/lc-longest-valid-parens
<span class="go">4
2
0
</span></code></pre></div></div>

<p>Just like we expected!</p>

<h2 id="youtube-video-description">YouTube Video Description</h2>

<p>We solve a hard leetcode problem in both BQN and CUDA C++ with the Thrust library.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Thanks for tuning in and I hope you enjoyed this example program.
You can find all the GPU examples I used in the links below.
Connor Hoekstra, if you’re reading or watching this, I hope to see you out-do my BQN and CUDA solutions in another video :).</p>

<h2> Contact </h2>

<p>You can reach me at any of the links below:</p>

<ul>
  <li><a target="_blank" href="https://www.youtube.com/c/AsherMancinelli">YouTube</a></li>
  <li><a target="_blank" href="https://www.linkedin.com/in/asher-mancinelli-bb4a56144/">LinkedIn</a></li>
  <li><a target="_blank" href="https://github.com/ashermancinelli">GitHub</a></li>
  <li><a target="_blank" href="mailto:ashermancinelli@gmail.com">Personal Email</a></li>
</ul>

<font size="-1">
  <em>
    These views do not in any way represent those of Pacific Northwest National Laboratory, the US Department of Energy, Battelle, or any other organization or institution that I, Asher Mancinelli, am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://github.com/ashermancinelli/portable-alg-testbed">Repo for GPU Examples</a></li>
  <li><a href="https://github.com/ashermancinelli/apl-snippets">Repo for BQN/APL Examples</a></li>
  <li><a href="https://www.youtube.com/channel/UCZ5sL4E662VP1ZwC4h85ttQ">YouTube Channel</a></li>
  <li><a href="http://www.ashermancinelli.com/">Blog</a></li>
  <li><a href="https://www.linkedin.com/in/asher-mancinelli-bb4a56144/">LinkedIn</a></li>
  <li><a href="https://leetcode.com/problems/longest-valid-parentheses/">LeetCode Problem</a></li>
</ul>

  </div>

  <hr>

  <div class="date">
    Written on Oct 11th, 2021
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:ashermancinelli@gmail.com"><i class="svg-icon email"></i></a>


<a href="https://github.com/ashermancinelli"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/https://www.linkedin.com/in/asher-mancinelli-bb4a56144/"><i class="svg-icon linkedin"></i></a>




<a href="https://youtube.com/channel/UCZ5sL4E662VP1ZwC4h85ttQ"><i class="svg-icon youtube"></i></a>

        </footer>
      </div>
    </div>
    
    <div>Icons made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
</div>
    
    

  </body>
</html>
