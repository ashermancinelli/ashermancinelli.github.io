<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-06-15T16:48:58-07:00</updated><id>/feed.xml</id><title type="html">Asher Mancinelli</title><subtitle>C++, Compilers, Coffee</subtitle><entry><title type="html">Sterling - 10/10</title><link href="/sterling" rel="alternate" type="text/html" title="Sterling - 10/10" /><published>2023-06-14T00:00:00-07:00</published><updated>2023-06-14T00:00:00-07:00</updated><id>/Sterling</id><content type="html" xml:base="/sterling"><![CDATA[<p>This place is something special. <em>Please</em> don‚Äôt leave Portland without trying their espresso.</p>

<hr />

<p>Prior to trying Sterling‚Äôs espresso, the #1 on my list was from Courier Coffee.
When I told the barista at Courier how much I enjoyed their espresso, he made sure to recommend Sterling for my next stop.</p>

<blockquote>
  <p>Oh, you like espresso? Yeah, you should definitely check out Sterling</p>
</blockquote>

<p>He backed that comment up with a few more remarks about how special their espresso is, and it went to the top of my list of places to try next.
It did not dissapoint.</p>

<hr />

<p>The barista was excited to welcome me in and tell me all about the roast they had ready for espresso, which happened to be the <em>Nigusse Lemma</em>, a natural-process small-batch Ethiopian roast with Etheopian Heriloom varietals.
I got the same feelings I get trying a new whiskey at the Scotch Lounge on the East side of town - she talked through the roasting process at their East-side roastery and the origins of the beans.</p>

<p>After pulling the shot, she put together a board with a small glass of sparkling water as a pallate clenser (as is usual in espresso-focused cafes).</p>

<p>Adding to the Scotch Lounge feelings, the espresso was served in a glencairn-style whiskey serving glass along with a third glass with a drip brew so as to try the roast from another perspective.</p>

<p>Both coffees were smooth and creamy - I jotted down <em>notes of strawberries and cream</em> before I even saw <em>‚ÄúRaspberry &amp; Vanilla Cream‚Äù</em> listed as flavor comps on the bag of coffee they used for my espresso.</p>

<hr />

<p>This espresso struck me as <strong><em>perfectly balanced</em></strong> - without hesitation, I wanted to share it with every one of my friends still not won over by espresso.
In my experience, when people try espresso and decide they hate it, 95% of the time it‚Äôs due to the intensity of the flavors, especially with sour and bitter notes.
When I try an intense espresso, something that punches you in the mouth with sourness or fruit or bitterness or chocolate or nuttiness, I can enjoy the intensity (if it‚Äôs done well!) - but that seems to be the attribute of espresso that puts people off of it.</p>

<p>This espresso was not intense in the usual way, but not too mild either.
It was full of flavor with delicious notes of citrus, cream, a balance of bitterness to round out the flavor profile, yet not too intense to be someone‚Äôs first espresso.</p>

<p>This espresso, along with their drip brew, the knowledgable baristas, and a cozy cafe seating area nestled into NW Portland with indoor trees and fast wifi brings this to the top of my list.</p>

<p>As I work out an espresso tour of Portland, I <em>have</em> to pencil Sterling in as the final destination.
I would want any espresso afficionado visiting the city to finish their time here with a Sterling espresso.</p>

<hr />

<h3>
    <center>
    <a href="https://www.sterling.coffee/" target="blank">
    Sterling Coffee homepage
    </a>
    </center>
</h3>]]></content><author><name></name></author><summary type="html"><![CDATA[This place is something special. Please don‚Äôt leave Portland without trying their espresso.]]></summary></entry><entry><title type="html">DEADSTOCK Coffee - 9.5/10</title><link href="/deadstock" rel="alternate" type="text/html" title="DEADSTOCK Coffee - 9.5/10" /><published>2023-06-14T00:00:00-07:00</published><updated>2023-06-14T00:00:00-07:00</updated><id>/Deadstock</id><content type="html" xml:base="/deadstock"><![CDATA[<p><strong><em>‚ÄúCoffee should be dope‚Äù</em></strong></p>

<hr />

<p>Nestled in central Chinatown, this cafe front for a roastery has their own streetwear line and feels like a trap-house recording studio.
Self-termed <strong><em>Portland‚Äôs Hype Barista</em></strong>, Nike Jordan 1s are hung up everywhere and trap plays over the speakers all day.</p>

<p>The <em>BREEZY Don Enrique</em> Colombian single-origin medium roast was <em>seriously</em> good.
As soon as I finish making this espresso tour, I plan on coming back here to buy a bag or two of the BREEZY - it was one of the best-smelling roasts I‚Äôve come across in the last year.</p>

<p>I haven‚Äôt seen DEADSTOCK mentioned on many blogs, which feels like an injustice.
Definitely worth stopping by.</p>

<hr />

<h3>
    <center>
    <a href="https://deadstockcoffee.com" target="blank">
    Deadstock Coffee homepage
    </a>
    </center>
</h3>]]></content><author><name></name></author><summary type="html"><![CDATA[‚ÄúCoffee should be dope‚Äù]]></summary></entry><entry><title type="html">Abba - 7/10</title><link href="/abba-roasters" rel="alternate" type="text/html" title="Abba - 7/10" /><published>2023-06-14T00:00:00-07:00</published><updated>2023-06-14T00:00:00-07:00</updated><id>/Abba</id><content type="html" xml:base="/abba-roasters"><![CDATA[<p>Enjoyable, but not my first recomendation.</p>

<hr />

<p>The Etheopian and Indonesian in-house medium roast (the <em>Collective Blend</em>) was subtle and tasty - I wasn‚Äôt smacked across the face with fruit or punched in the nose with dark-chocolately bitterness.
The notes on the package mentioned dark cherry and pear; I can see where they got <em>pear</em> but <em>grapefruit</em> is the predominant flavor that came to mind.</p>

<p>It was enjoyable! I would have it again, but I‚Äôm not rushing back or sending out recomendations to all my friends.</p>

<p>The <em>sea-salt iced matcha latte</em> the person in front of me ordered looked beautiful, and I heard several people mention how much they liked it - if you‚Äôre a matcha latte kinda person, this might be a fun stop.</p>

<hr />

<h3>
    <center>
    <a href="https://www.abbacoffeeroasters.com" target="blank">
    Abba Coffee Roasters homepage
    </a>
    </center>
</h3>]]></content><author><name></name></author><summary type="html"><![CDATA[Enjoyable, but not my first recomendation.]]></summary></entry><entry><title type="html">PDX Espresso Research</title><link href="/pdx-espresso-research" rel="alternate" type="text/html" title="PDX Espresso Research" /><published>2023-06-14T00:00:00-07:00</published><updated>2023-06-14T00:00:00-07:00</updated><id>/PDX-Espresso-Research</id><content type="html" xml:base="/pdx-espresso-research"><![CDATA[<p>All the Portland espresso recomendations I could find online, and the shops that keep coming up.</p>

<hr />

<h1 id="my-takeaways">My Takeaways</h1>

<p>The most common names in these blogs are probably:</p>

<ol>
  <li>Coava</li>
  <li>Proud Mary</li>
  <li>Case Study</li>
  <li>Heart</li>
  <li>Stumptown</li>
</ol>

<p>If you visit any given cafe in Portland, chances are high their beans come from either Heart, Coava or Proud Mary, and for good reason.
All three of them are local and put out some <em>solid</em> roasts‚Ä¶ but I still recommend finding some smaller shops that still roast in-house.</p>

<p>In my opinion, the most underrated cafes and roasters are probably:</p>

<ol>
  <li>Deadstock</li>
  <li>Courier</li>
</ol>

<p>and the most overrated are:</p>

<ol>
  <li>Stumptown</li>
  <li>Case Study</li>
  <li>Never Coffee (unless you really like lattes)</li>
  <li>PUSH X PULL</li>
</ol>

<h1 id="lists-from-other-blogs">Lists From Other Blogs</h1>

<p><em>As of Jun 15 2023</em></p>

<h2 id="pdx-monthly"><a href="https://www.pdxmonthly.com/eat-and-drink/best-coffee-shops-cafes-portland">PDX Monthly</a></h2>

<p>Perhaps the most solid collection of Portland roasters and cafes, I found several shops I‚Äôd never heard of while it doesn‚Äôt miss the usual suspects.</p>

<ol>
  <li>Abba</li>
  <li>Albina Press</li>
  <li>Carnelian Coffee</li>
  <li>Case Study</li>
  <li>Cathedral Coffee</li>
  <li>Courier Coffee</li>
  <li>Deadstock</li>
  <li>Either/Or</li>
  <li>Electrica</li>
  <li>The Fresh Pot</li>
  <li>Futura Coffee Roasters</li>
  <li>Good Coffee</li>
  <li>Guilder</li>
  <li>Heart</li>
  <li>In J/Super Joy</li>
  <li>J Vein Caffe</li>
  <li>Kalesa</li>
  <li>Keeper Coffee</li>
  <li>Less and More</li>
  <li>Never Coffee</li>
  <li>Portland C√† Ph√™</li>
  <li>Prince Coffee</li>
  <li>PUSH X PULL</li>
  <li>Roseline</li>
  <li>Soro Soro</li>
  <li>Sterling Coffee</li>
  <li>ToÃÑv Coffee</li>
  <li>Upper Left Roasters</li>
</ol>

<h2 id="oregon-obsessed"><a href="https://oregonobsessed.com/best-coffee-shops-in-portland/">Oregon Obsessed</a></h2>

<p>I‚Äôve tried (and liked) almost all of <em>Oregon Obsessed</em>‚Äôs recomendations, though a few are overrated in my opinion:</p>

<ol>
  <li>Coava</li>
  <li>Good Coffee</li>
  <li>Stumptown</li>
  <li>Case Study</li>
  <li>Nossa Familia</li>
  <li>Proud Mary</li>
  <li>Deadstock</li>
  <li>Never Coffee</li>
  <li>Ovation</li>
  <li>Portland Coffee Roasters</li>
</ol>

<h2 id="daily-hive"><a href="https://dailyhive.com/portland/best-coffee-shops-portland">Daily Hive</a></h2>

<p>Good to see <em>Coava</em> consistently topping these lists - hadn‚Äôt heard of P√°jaro either.</p>

<ol>
  <li>Coava</li>
  <li>P√°jaro</li>
  <li>PUSH X PULL</li>
  <li>Heart Coffee</li>
  <li>Stumptown</li>
  <li>Upper Left</li>
  <li>Deadstock</li>
  <li>Good Coffee</li>
</ol>

<h2 id="coffee-affection"><a href="https://coffeeaffection.com/best-coffee-shops-in-portland/">Coffee Affection</a></h2>

<p>Pretty much just hits the usual suspects.
Not much is new here.</p>

<ol>
  <li>Coava</li>
  <li>Good Coffee</li>
  <li>Stumptown</li>
  <li>Case Study</li>
  <li>Nossa Familia</li>
  <li>Proud Mary</li>
  <li>Deadstock</li>
  <li>Never Coffee</li>
  <li>Ovation</li>
  <li>Portland Coffee Roasters</li>
</ol>

<h2 id="foursquare"><a href="https://foursquare.com/top-places/portland/best-places-espresso">FourSquare</a></h2>

<ol>
  <li>Barista</li>
  <li>Coava</li>
  <li>Stumptown</li>
  <li>Case Study</li>
  <li>Heart</li>
  <li>Courier</li>
  <li>Spella</li>
  <li>Sterling</li>
  <li>Water Avenue</li>
  <li>Good Coffee</li>
  <li>Common Grounds</li>
  <li>Nossa Familia</li>
</ol>

<h2 id="hopculture"><a href="https://www.hopculture.com/best-coffee-portland-oregon/">HopCulture</a></h2>

<p>I hadn‚Äôt seen Kiosko before:</p>

<ol>
  <li>Proud Mary</li>
  <li>Kiosko</li>
  <li>Heart</li>
  <li>Stumptown</li>
  <li>Never Coffee Lab</li>
  <li>Good Coffee</li>
  <li>Coava</li>
</ol>

<h2 id="boam"><a href="https://boam.com/best-espresso-shops-in-portland-or/">Boam</a></h2>

<p><em>Fairlane</em> is the only name on this list new to me.
Pretty solid list.</p>

<ol>
  <li>Good Coffee</li>
  <li>Nossa Familia</li>
  <li>PUSH X PULL</li>
  <li>Sunny Day Coffee</li>
  <li>Ole Latte Coffee</li>
  <li>Ovation Coffee &amp; Tea</li>
  <li>Fairlane Coffee</li>
  <li>Sisters Coffee Company in The Pearl</li>
  <li>Coava</li>
  <li>Grendel‚Äôs Coffee House</li>
</ol>

<h2 id="respresso-subreddit"><a href="https://www.reddit.com/r/espresso/comments/12jbj4m/best_espresso_in_portland_or/">R/Espresso Subreddit</a></h2>

<p>As of the time of writing, many subreddits are protesting a recent change to reddit‚Äôs 3rd party API access rules, so I can‚Äôt view the listright now.</p>

<h2 id="bean-box"><a href="https://beanbox.com/blog/best-coffee-in-portland">Bean Box</a></h2>

<ol>
  <li>Roseline Coffee</li>
  <li>Water Avenue Coffee Company</li>
  <li>Coava</li>
  <li>Good Coffee</li>
  <li>Ovation</li>
  <li>Proud Mary</li>
  <li>Prince</li>
  <li>Either/Or</li>
  <li>Heart Cofffee Roasters</li>
  <li>Nossa Familia Coffee</li>
  <li>Stumptown</li>
</ol>

<h2 id="trip-advisor"><a href="https://www.tripadvisor.com/Restaurants-g52024-c8-Portland_Oregon.html">Trip Advisor</a></h2>

<p>This list is focused on <em>cafes</em> and not really <em>coffee</em>‚Ä¶ there were some names on this list I hadn‚Äôt seen before, so I‚Äôll keep it around‚Ä¶ but I wouldn‚Äôt put much weight on these names (hence why it comes last in my research page).</p>

<ol>
  <li>Chery‚Äôs on 12th</li>
  <li>St Honore</li>
  <li>Tin Shed Garden Cafe</li>
  <li>Jam on Hawthorne</li>
  <li>Island Cafe</li>
  <li>Ken‚Äôs Artisan Bakery</li>
  <li>Stumptown</li>
  <li>The Waffle Window</li>
  <li>Case Study</li>
  <li>Cadillac Cafe</li>
  <li>Milo‚Äôs City Cafe</li>
  <li>Broder</li>
  <li>Lovejoy</li>
  <li>Gravy</li>
  <li>Dragonfly Coffee House</li>
  <li>Zell‚Äôs</li>
  <li>Bleu Door Bakery</li>
  <li>Petunia‚Äôs Pies &amp; Pastries</li>
  <li>Cameo Cafe</li>
  <li>Public Domain Coffee</li>
  <li>Stepping Stone Cafe</li>
  <li>The Daily Feast PDX</li>
  <li>Barista</li>
  <li>Dulin‚Äôs Cafe</li>
  <li>Heart Coffee</li>
  <li>Babica Hen Cafe</li>
  <li>Prasad</li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[All the Portland espresso recomendations I could find online, and the shops that keep coming up.]]></summary></entry><entry><title type="html">Never Coffee - 5/10</title><link href="/never-coffee" rel="alternate" type="text/html" title="Never Coffee - 5/10" /><published>2023-06-13T00:00:00-07:00</published><updated>2023-06-13T00:00:00-07:00</updated><id>/Never-Coffee</id><content type="html" xml:base="/never-coffee"><![CDATA[<p>Not my favorite, but it might be yours.</p>

<p>The Never Coffee cafe on SW 12th and Alder is one of the nicest cafe environments I‚Äôve found so far, with a modern feel and pastel color palette. 
They got a low score from me simply because their espresso was not my favorite - it felt a little bland, not overly fruity or dark and rich, somewhere in the middle with less flavor than I was hoping for.</p>

<p>I had their Bangarang roast, a blend of washed Kenyan, washed Peruvian, and honey-process Honduran beans, which the barista was more than happy to tell me about - they clearly care about coffee, roast in-house, and take creative steps with their drinks, but their espresso was not for me and that‚Äôs my measuring stick.</p>

<p>Other reviews of Never Coffee call out their lattes as very above-average, which seems to be the case; almost every single person I saw in the cafe in the morning I spent there chose one of their 5 unique latte flavors, and I was the only one with a doppio.</p>

<p>If you stop by, maybe try one of their lattes.</p>

<p><a href="https://nevercoffeelab.com/">Never Coffee homepage</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Not my favorite, but it might be yours.]]></summary></entry><entry><title type="html">Coava - 10/10</title><link href="/coava" rel="alternate" type="text/html" title="Coava - 10/10" /><published>2023-06-13T00:00:00-07:00</published><updated>2023-06-13T00:00:00-07:00</updated><id>/Coava</id><content type="html" xml:base="/coava"><![CDATA[<p>They say you never forget your first love‚Ä¶</p>

<hr />

<p><strong><em>‚Ä¶and Coava was mine.</em></strong></p>

<p>They are the first Portland-local roaster and cafe I fell in love with.</p>

<p>When I first moved to Portland, there was a Coava cafe in the same building as my apartment, on the lobby floor.
Nearly all 5 work-days, nearly every week since I moved here, I worked from that cafe in the upstairs seating area surrounded by Monstera Deliciosas, PSU students, and speakers playing indi tracks I‚Äôd never heard before.</p>

<p>I‚Äôve consumed more Coava espresso than any other form of espresso in my life by a <strong><em>long shot</em></strong>.
It‚Äôs no surprise that they earn a perfect 10/10; fruity but not too blond, bitter but not too dark.</p>

<p>I‚Äôll forever mourn their west-side location, but their headquarters shop on SE Main and Grand right off the 6 bus line is a much nicer cafe anyways.
The seating area is home to beautiful woodworking projects from <em>Bamboo Revolution</em> with whom Coava shares a space, along with antique roasting equipment and open-air garage doors and fans (at least in the summer time).</p>

<p>For this review I had a doppio of the <em>Java Papatong</em>, a washed-process from Indonesia, but I‚Äôve loved many of their other roasts:</p>

<ul>
  <li>the San Marcos,</li>
  <li>the SO Blend from the Americas and East Africa,</li>
  <li>the Darfusu washed process,</li>
  <li>the Fazenda Serra do Bon√© from Brazil,</li>
</ul>

<p>and plenty of others. Their roasts are all seasonal, so try whatever they have.</p>

<hr />

<center>
    <h3>
       <a href="https://coavacoffee.com" target="blank">Coava Homepage</a> 
    </h3>
</center>]]></content><author><name></name></author><summary type="html"><![CDATA[They say you never forget your first love‚Ä¶]]></summary></entry><entry><title type="html">Dummy‚Äôs Guide to VLA/VLS Arm Development</title><link href="/arm-vla-vls" rel="alternate" type="text/html" title="Dummy‚Äôs Guide to VLA/VLS Arm Development" /><published>2023-06-12T00:00:00-07:00</published><updated>2023-06-12T00:00:00-07:00</updated><id>/ARM-VLA</id><content type="html" xml:base="/arm-vla-vls"><![CDATA[<p>description</p>

<font size="-1">
  <em>
    These views do not in any way represent those of NVIDIA or any other organization or institution that I am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="title">title</h2>

<h2 id="conclusion--links">Conclusion &amp; Links</h2>

<ol>
  <li><a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">GCC VLA docs</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Alloca-Example.html">GCC <code class="language-plaintext highlighter-rouge">alloca</code> docs</a></li>
</ol>

<font size="-1">
  <em>
    These views do not in any way represent those of NVIDIA or any other organization or institution that I am professionally associated with.
    These views are entirely my own.
  </em>
</font>]]></content><author><name></name></author><summary type="html"><![CDATA[description]]></summary></entry><entry><title type="html">Hunt for the Best Espresso in Portland</title><link href="/espresso-pdx" rel="alternate" type="text/html" title="Hunt for the Best Espresso in Portland" /><published>2023-06-11T00:00:00-07:00</published><updated>2023-06-11T00:00:00-07:00</updated><id>/Best-Espresso-In-Portland</id><content type="html" xml:base="/espresso-pdx"><![CDATA[<p>Finding the best espresso in one of the homes of 3rd-wave coffee.</p>

<h2 id="the-plan">The Plan</h2>

<p>In the spring and summer of 2023 I started a list of coffee shops to evaluate.
By the end of the summer I hope to have established a rough ranking of the best shops,
along with some honorable mentions for great shops to work from.</p>

<p>Here are some of the early contenders:</p>

<center>
  <img src="/images/coffee/courier.png" />
</center>

<p>The second shop to get a 10/10 on my arbitrary rating system blew me away.
I‚Äôm not usually a huge fan of fruity espresso, but the double-fermented Las Frutas roasted in-house was the best espresso I‚Äôve had to date.
The columbian beans were sealed in water bags for 72 hours before another 30 hour wet-tank soak were incredible.
The roaster and barista recomended Sterling Coffee Roasters for my next espresso, so I‚Äôm hopeful that Sterling will rate pretty highly as well.</p>

<center>
  <img src="/images/coffee/ovation.png" />
</center>

<p>Ovation Coffee and Tea was the first shop to be awarded a perfect 10/10.
The location in PSU‚Äôs campus right off the North-South streetcar line has plenty of space to work and REALLY cute porcelein cups.</p>

<h2 id="behind-the-museum">Behind the Museum</h2>

<p>The Behind the Museum cafe‚Äôs beautiful floor-to-ceiling windows and Japanese pottery along the walls make for an
especially nice work environment, especially when it‚Äôs raining -
the rain rolling off those massive windows immediately puts you at ease.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Finding the best espresso in one of the homes of 3rd-wave coffee.]]></summary></entry><entry><title type="html">Understanding VLA</title><link href="/vla-c" rel="alternate" type="text/html" title="Understanding VLA" /><published>2023-06-01T00:00:00-07:00</published><updated>2023-06-01T00:00:00-07:00</updated><id>/C-VLA-Implementation</id><content type="html" xml:base="/vla-c"><![CDATA[<p>Scattered notes from learning about the implementation of VLA.</p>

<font size="-1">
  <em>
    These views do not in any way represent those of NVIDIA or any other organization or institution that I am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="what-is-vla">What is VLA?</h2>

<p>Variable-length arrays are dynamic, stack-allocated arrays.
The compiler needs to increase the stack size in the current stack frame to allocate enough space for the array.
Assuming negative stack-growth like on x86, the compiler will decrease the stack pointer sufficiently to store the array.</p>

<p>This is almost identical to <code class="language-plaintext highlighter-rouge">alloca</code>.
Both <code class="language-plaintext highlighter-rouge">alloca</code> and VLAs are essentially primitives to modify the stack pointer.</p>

<p>Eg:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Subtracts N from current stack pointer returns sp </span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">curr_sp</span> <span class="o">=</span> <span class="n">alloca</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="c1">// equivilant to</span>
  <span class="kt">int</span> <span class="n">curr_sp</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</code></pre></div></div>

<p><a href="https://stackoverflow.com/questions/3488821/is-alloca-completely-replaceable">One key difference between the two:</a></p>
<blockquote>
  <p>The memory alloca() returns is valid as long as the current function persists. The lifetime of the memory occupied by a VLA is valid as long as the VLA‚Äôs identifier remains in scope. You can <code class="language-plaintext highlighter-rouge">alloca</code> memory in a loop for example and use the memory outside the loop, a VLA would be gone because the identifier goes out of scope when the loop terminates.</p>
</blockquote>

<h2 id="memory-layout">Memory Layout</h2>

<p>Because the stack grows down on most platforms, the stack pointer after an <code class="language-plaintext highlighter-rouge">alloca</code> or VLA allocation but arrays are addressed sequentially upwards, the address of the first element of a VLA array (or the pointer returned by <code class="language-plaintext highlighter-rouge">alloca</code>) will be the value of the stack pointer <em>after</em> it‚Äôs modified.</p>

<center>
  <img style="background-color:#240057;" src="/images/vla/vla-stack-pointer-viz.drawio.png" />
</center>

<p>Element 0 of the array or <code class="language-plaintext highlighter-rouge">alloca</code>-allocated memory is therefore immediately above the stack pointer after allocation, and is addressed by increasing sequentially until the end of the array.
Accessing past the array will then run into previously declared stack variables.</p>

<p>When the function returns, the stack space will be available for subsequent function calls to use automatically, so there is no need to explicitly free memory allocated by VLA/<code class="language-plaintext highlighter-rouge">alloca</code>.</p>

<h2 id="examples">Examples</h2>

<p>GCC docs:</p>
<blockquote>
  <p>These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits.</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ./vla &lt;size&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Declaring the array decrements the stack pointer enough to provide memory for the array:
<!--
gcc _includes/vla/inspect-stack.c && LEN=10 IDX=4 ./a.out
--></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span>
<span class="cp">#define SAVESTACK(X) asm( "mov %%rsp, %0" : "=rm" ( X ));
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"LEN"</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"IDX"</span><span class="p">));</span>
  <span class="k">register</span> <span class="kt">uint64_t</span> <span class="n">sp0</span><span class="p">,</span> <span class="n">sp1</span><span class="p">;</span>

  <span class="n">SAVESTACK</span><span class="p">(</span><span class="n">sp0</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">vla</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>

  <span class="n">SAVESTACK</span><span class="p">(</span><span class="n">sp1</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">vla</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"&amp;vla[0]: %ld</span><span class="se">\n</span><span class="s">before: %ld</span><span class="se">\n</span><span class="s">after: %ld</span><span class="se">\n</span><span class="s">diff: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vla</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp0</span><span class="p">,</span> <span class="n">sp1</span><span class="p">,</span> <span class="n">sp0</span><span class="o">-</span><span class="n">sp1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">vla</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">uname</span> <span class="nt">-a</span>
Linux carbon 5.15.0-71-generic <span class="c">#78-Ubuntu SMP Tue Apr 18 09:00:29 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span>
<span class="nv">$ </span>gcc inspect-stack-vla.c <span class="o">&amp;&amp;</span> <span class="nv">LEN</span><span class="o">=</span>10 <span class="nv">IDX</span><span class="o">=</span>4 ./a.out
&amp;vla[0]: 140737151458112
before: 140737151458160
after: 140737151458112
diff: 48
</code></pre></div></div>

<p>Notice that the address stored in the stack pointer after declaring the VLA array is the same as the address of the first element of the VLA array as depicted in the diagram above.</p>

<h2 id="alloca"><code class="language-plaintext highlighter-rouge">alloca</code></h2>

<p>Instead of declaring a VLA array, we can create a pointer to memory allocated by <code class="language-plaintext highlighter-rouge">alloca</code> to produce the same effect:
<!--
gcc _includes/vla/inspect-stack-alloca.c && LEN=10 IDX=4 ./a.out
--></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;alloca.h&gt;</span><span class="cp">
</span>
<span class="cp">#define SAVESTACK(X) asm( "mov %%rsp, %0" : "=rm" ( X ));
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"LEN"</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"IDX"</span><span class="p">));</span>
  <span class="k">register</span> <span class="kt">uint64_t</span> <span class="n">sp0</span><span class="p">,</span> <span class="n">sp1</span><span class="p">;</span>

  <span class="n">SAVESTACK</span><span class="p">(</span><span class="n">sp0</span><span class="p">);</span>

  <span class="c1">// int vla[len];</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">vla</span> <span class="o">=</span> <span class="n">alloca</span><span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="n">SAVESTACK</span><span class="p">(</span><span class="n">sp1</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">vla</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"&amp;vla[0]: %ld</span><span class="se">\n</span><span class="s">before: %ld</span><span class="se">\n</span><span class="s">after: %ld</span><span class="se">\n</span><span class="s">diff: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vla</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp0</span><span class="p">,</span> <span class="n">sp1</span><span class="p">,</span> <span class="n">sp0</span><span class="o">-</span><span class="n">sp1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">vla</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc inspect-stack-alloca.c <span class="o">&amp;&amp;</span> <span class="nv">LEN</span><span class="o">=</span>10 <span class="nv">IDX</span><span class="o">=</span>4 ./a.out
&amp;vla[0]: 140728646054592
before: 140728646054640
after: 140728646054592
diff: 48
</code></pre></div></div>

<p>Compare the GCC docs for <code class="language-plaintext highlighter-rouge">alloca</code> with that of variable length arrays and notice the similarities:</p>

<blockquote>
  <p>The function alloca supports a kind of half-dynamic allocation in which blocks are allocated dynamically but freed automatically.</p>

  <p>Allocating a block with alloca is an explicit action; you can allocate as many blocks as you wish, and compute the size at run time. But all the blocks are freed when you exit the function that alloca was called from, just as if they were automatic variables declared in that function. There is no way to free the space explicitly.</p>
</blockquote>

<h2 id="why-might-this-be-a-bad-idea">Why Might This Be a Bad Idea?</h2>

<p>The dynamic nature of VLAs means the offset of stack variables declared after the VLA into the stack frame of the function is <strong>also dynamic</strong> - which means the function will need extra instructions to calculate the address of these variables whenever they are referenced in the body of the function.</p>

<p>This <em>may</em> be a worthwhile tradeoff, but know that use of VLAs means your code may need a few extra instructions every time you use stack variables.</p>

<!--
## LLVM IR

Docs explanation of alloca:

> The ‚Äòalloca‚Äô instruction allocates memory on the stack frame of the currently executing function, to be automatically released when this function returns to its caller

< !--
clang -S -emit-llvm -o - _includes/vla/simple.c
-- >
```c
#include <stdlib.h>
#include <stdio.h>

/* Contrived example that uses VLA */
int main(int argc, char** argv) {
  int len = atoi(getenv("LEN"));
  int idx = atoi(getenv("IDX"));
  int vla[len];
  return vla[idx];
}

```
```llvm
@.str = private unnamed_addr constant [4 x i8] c"LEN\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"IDX\00", align 1

define dso_local i32 @main(i32 noundef %0, i8** noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i8*, align 8
  %9 = alloca i64, align 8
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  %10 = call i8* @getenv(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0)) #4
  %11 = call i32 @atoi(i8* noundef %10) #5
  store i32 %11, i32* %6, align 4
  %12 = call i8* @getenv(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0)) #4
  %13 = call i32 @atoi(i8* noundef %12) #5
  store i32 %13, i32* %7, align 4
  %14 = load i32, i32* %6, align 4
  %15 = zext i32 %14 to i64

  %16 = call i8* @llvm.stacksave()

  store i8* %16, i8** %8, align 8
  %17 = alloca i32, i64 %15, align 16
        ^^^^^^^^^^ Dynamically allocate more memory on the stack by decrementing
                   the stack pointer, giving sufficient space for the array

  store i64 %15, i64* %9, align 8
  %18 = load i32, i32* %7, align 4
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i32, i32* %17, i64 %19
  %21 = load i32, i32* %20, align 4
  store i32 %21, i32* %3, align 4
  %22 = load i8*, i8** %8, align 8
  call void @llvm.stackrestore(i8* %22)
  %23 = load i32, i32* %3, align 4
  ret i32 %23
}
```
-->

<h2 id="conclusion--links">Conclusion &amp; Links</h2>

<ol>
  <li><a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">GCC VLA docs</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Alloca-Example.html">GCC <code class="language-plaintext highlighter-rouge">alloca</code> docs</a></li>
  <li><a href="https://llvm.org/docs/LangRef.html#alloca-instruction">LLVM IR docs for <code class="language-plaintext highlighter-rouge">alloca</code> instruction</a></li>
  <li><a href="https://llvm.org/doxygen/Instructions_8cpp_source.html">LLVM source for <code class="language-plaintext highlighter-rouge">alloca</code> instruction</a></li>
  <li><a href="https://en.cppreference.com/w/c/language/array">cppreference docs on VLA</a></li>
  <li><a href="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html">Buffer overflow and stack frame visualization</a></li>
</ol>

<font size="-1">
  <em>
    These views do not in any way represent those of NVIDIA or any other organization or institution that I am professionally associated with.
    These views are entirely my own.
  </em>
</font>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[Scattered notes from learning about the implementation of VLA.]]></summary></entry><entry><title type="html">Debugging Performance in Compilers</title><link href="/comp-debug-perf" rel="alternate" type="text/html" title="Debugging Performance in Compilers" /><published>2022-12-12T00:00:00-08:00</published><updated>2022-12-12T00:00:00-08:00</updated><id>/Compiler-Perf-Debugging</id><content type="html" xml:base="/comp-debug-perf"><![CDATA[<p>Overview of how I debug performance regressions when developing a compiler.
I don‚Äôt claim this is the best way to do it, email me or tweet at me if you‚Äôve got better ideasüòâ</p>

<font size="-1">
  <em>
    These views do not in any way represent those of NVIDIA or any other organization or institution that I am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="starting-point">Starting Point</h2>

<p>Compilers are very complicated and the results can be surprising.
Sometimes performance issues only show up in large scale real-world applications.
How do you go about debugging such an issue?</p>

<p>As you might expect, narrowing down the issue to be minimal and reproducible is the first task.
Ideally, we narrow the performance regression down to a single translation unit, though sometimes this isn‚Äôt enough.
For this post, we‚Äôll assume that the bulk of the performance regression you see in your application is coming from one translation unit, and that you know which patch is causing the regression (if you don‚Äôt know which patch is causing the regression‚Ä¶ well you can bisect the recent patches tooüòÅ).</p>

<h2 id="bisecting-the-object-files">Bisecting the Object Files</h2>

<p>Assume we have two compilers: compiler A which doesn‚Äôt have the ‚Äúbad‚Äù changes (the ‚Äúgood‚Äù compiler), and compiler B which does (the ‚Äúbad‚Äù compiler).
We‚Äôll start by building the application with both compilers, building half of the object files with compiler A and half with compiler B.
Say we have 100 object files that are linked into the application; we‚Äôd build the first 50 with compiler A and the second 50 with compiler B.</p>

<p>If the perf regression isn‚Äôt observed after you re-link all the object files into the application, then we know the bulk of the issue is in the object files that were just built with compiler A.
We can then rebuild all the object files in the second 50 with compiler A and build object files 26-50 or 1-25 with compiler B.
In this way, we bisect all the translation units until we find the single TU with the largest impact on performance.</p>

<p>This can be really tedious and manual, but it‚Äôs not too hard to scriptüòâ.</p>

<h2 id="bisecting-the-source-file">Bisecting the Source File</h2>

<p>Now that we‚Äôve narrowed our regression down to a single TU, our work gets a little more complicated.
We can use the same bisection process as before, but this time we‚Äôll have to do it on a single file.
To acomplish this, we‚Äôll have to figure out which parts of the source file depend on each other so we can break it into two new source files, one to be built with compiler A and one to be built with compiler B (all other TUs being built with the ‚Äúgood‚Äù compiler).</p>

<p>Depending on the situation you may create two source files, each with half of the content of the original, or maybe you‚Äôll use the same source file but use macro guards so each compiler only builds half of the source, eg:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* includes, declarations, and global defs up here */</span>

<span class="cp">#ifdef COMPILERA
</span><span class="c1">// stuff built with the good compiler...</span>
<span class="cp">#else </span><span class="cm">/* COMPILERB */</span><span class="cp">
</span><span class="c1">// stuff built with the bad compiler...</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>You may then add <code class="language-plaintext highlighter-rouge">-DCOMPILERA</code> to the invokation of compiler A so each compiler only builds half of the TU in question.
Again, if we don‚Äôt see the perf regression, we swap the macro guards and try again.
We then have compiler B build a quarter of the original TU and have compiler A build the other 3/4ths, and see if we observe the regression, etc etc.
Ideally, at the end of this process we know exactly which function(s) are causing the regression.</p>

<h2 id="what-next">What Next?</h2>

<p>After we‚Äôve narrowed the regression down to a function or two (ü§û) things can get tricky, and very much depends on the nature of the changes that caused the regression.</p>

<p>At this point I think it‚Äôs best to ask some questions:</p>

<ul>
  <li>Was the patch in question related to a specific pass?
    <ul>
      <li>Can the effects of that pass be seen in the function(s) we found to be causing the regression?</li>
      <li>Is the regression observed when the pass is disabled?</li>
    </ul>
  </li>
  <li>Do you notice any obvious differences between the IR the compilers generate for the identified functions?
    <ul>
      <li>Can you use those differences to work backwards to the code that generated that IR?</li>
    </ul>
  </li>
  <li>If you enable lots of debugging output (like dumping all the <code class="language-plaintext highlighter-rouge">opt</code> pass remarks) and build with compilers A and B and then diff the output, are there any glaring differences? Maybe an earlier change allowed another pass (uninvolved in the patch) to perform some transformations it otherwise would not, or maybe vice-versa.</li>
</ul>

<h2 id="why-might-this-not-work">Why Might This Not Work?</h2>

<p>Sometimes the effects only occur in a short function that is always inlined, in which case you might not find a specific TU or set of functions at the root of the regression; for this reason, you might want to crank the inlining pass down as low as it goes to help you narrow down the issue.
It‚Äôs often best to use the fewest optimizations possible when debugging this sort of thing (so long as you still observe the behavior).
<!--
--></p>]]></content><author><name></name></author><category term="c++, llvm, compilers" /><summary type="html"><![CDATA[Overview of how I debug performance regressions when developing a compiler. I don‚Äôt claim this is the best way to do it, email me or tweet at me if you‚Äôve got better ideasüòâ]]></summary></entry></feed>