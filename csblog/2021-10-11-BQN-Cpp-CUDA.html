<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BQN and CUDA C++ LeetCode Solutions 10/11/2021 - Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded affix "><li class="part-title">Blog</li><li class="chapter-item expanded "><a href="../csblog/2024-9-4-Debugging-In-Parallel.html">Debugging in Parallel 9/4/2024</a></li><li class="chapter-item expanded "><a href="../notes/2024-8-31-Linux-Perf-Notes.html">The Linux Perf Tool 8/31/2024</a></li><li class="chapter-item expanded "><a href="../notes/values.html">Values 8/26/2024</a></li><li class="chapter-item expanded "><a href="../notes/2024-8-30-Shell.html">Shell+Scripting 8/24/2024</a></li><li class="chapter-item expanded "><a href="../notes/editors.html">Editors+Tools 8/24/2024</a></li><li class="chapter-item expanded "><a href="../csblog/2023-6-1-C-VLA-Implementation.html">Understanding VLA 6/1/2023</a></li><li class="chapter-item expanded "><a href="../csblog/2022-5-2-BQN-reflections.html">BQN and Reflections on the Joy of Programming 5/2/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-2-2-LLVM-Development-On-NixOS.html">LLVM Development on NixOS 2/2/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-2-10-CUDA-101-Matvec.html">CUDA 101: Matrix-Vector Product 2/10/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-12-12-Compiler-Perf-Debugging.html">Debugging Performance in Compilers 12/12/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-1-15-Std-Expected.html">std::expected And Why It's Awesome 1/15/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-7-GTest-Type-Value-Params.html">GTest Type and Value Parameterized Tests 3/7/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-6-Spack-Development-3.html">Spack for Package Development Part 3 3/6/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-6-Clang-Tools-Lambda.html">Clang Tools for Checking Domain-Specific Errors 3/6/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-5-Spack-Development-2.html">Spack for Package Development Part 2 3/5/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-4-Spack-Development-1.html">Spack for Package Development Part 1 3/4/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-12-23-std-mdspan-Response.html">A Look at std::mdspan 12/23/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-10-24-Popular-Languages-1965.html">Using the Most Popular Programming Languages of the '60s 10/24/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-10-19-Leetcode-And-Distributed-Computing.html">One Problem, Four Languages, Two Paradigms 10/19/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-10-11-BQN-Cpp-CUDA.html" class="active">BQN and CUDA C++ LeetCode Solutions 10/11/2021</a></li><li class="chapter-item expanded affix "><li class="part-title">Coffee</li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-11-Best-Espresso-In-Portland.html">Best Espresso In Portland (6/11/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-22-Sterling.html">Sterling (6/22/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-Deadstock.html">Deadstock (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-22-Barista.html">Barista (6/22/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-13-Never-Coffee.html">Never Coffee (6/13/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Upper-Left-Roasters.html">Upper Left Roasters (6/15/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-Abba.html">Abba (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Rose-City-Coffee.html">Rose City Coffee (6/15/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-Sterling.html">Sterling (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-21-Superjoy.html">Superjoy (6/21/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-13-Beginners-Guide.html">Beginners Guide (6/13/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-19-Seattle-Trip-Report.html">Seattle Trip Report (6/19/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Adapt-Coffee.html">Adapt Coffee (6/15/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-13-Coava.html">Coava (6/13/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-PDX-Espresso-Research.html">PDX Espresso Research (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Nossa-Familia-Coffee.html">Nossa Familia Coffee (6/15/2023)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
layout: post
title: BQN and CUDA C++ LeetCode Solutions
permalink: /bqn-cuda-cpp-lc-longest-valid-parens
category: bqn, c++, cuda, leetcode
wip: false
cat: cs
-->
<p>Solving a hard leetcode problem in the BQN APL dialect and CUDA C++!</p>
<p><em>NOTE: This post is a transcript of <a href="https://youtu.be/3D7sfXzBBXE">the youtube video linked here</a>.</em></p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Hello everyone, today Iâ€™d like to go through two solutions to a LeetCode problem.
Weâ€™ll first look at the solution with the BQN array language, and then weâ€™ll look at a GPU-capable solution in CUDA that uses the Thrust template library.</p>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses/">Link here</a>.</p>
<p>Given a string containing just the characters â€˜(â€™ and â€˜)â€™, find the length of the longest valid parentheses substring.</p>
<p>For example, for the string <code>")()())"</code> the expected answer is 4, and for this string the expected answer is two: <code>"())"</code>. Of course, for an empty string the answer is 0.</p>
<p>Weâ€™ll be looking at the solution in BQN first.</p>
<h2 id="bqnapl-solution"><a class="header" href="#bqnapl-solution">BQN/APL Solution</a></h2>
<p>Here is the full solution:</p>
<pre><code>   F â† {0âŒˆ1+âŒˆÂ´âŒˆÂ´Â¨âˆ¾Â¨1â†“Â¨âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©}
   F ")()())"
4
   F "(()"
2
   F ""
0
</code></pre>
<p>I take the index into the string <code>")("</code> to convert to integers and I take all the prefixes of that array.</p>
<pre><code>   {â†“")("âŠ¸âŠ ğ•©} "(()"
âŸ¨ âŸ¨ 1 1 0 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 0 âŸ© âŸ¨âŸ© âŸ©
</code></pre>
<p>I then multiply by two and subtract one so each index represents the change in the level of nesting at that index.</p>
<pre><code>   {1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} "(()"
âŸ¨ âŸ¨ 1 1 Â¯1 âŸ© âŸ¨ 1 Â¯1 âŸ© âŸ¨ Â¯1 âŸ© âŸ¨âŸ© âŸ©
</code></pre>
<p>I then plus-scan to find the cumulative level of nesting up to that index for each prefix of the array:</p>
<pre><code>   {+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} "(()"
âŸ¨ âŸ¨ 1 2 1 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ Â¯1 âŸ© âŸ¨âŸ© âŸ©
</code></pre>
<p>Find the zeros in each prefix, since these are the locations where the substring is balanced:</p>
<pre><code>   {0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} "(()"
âŸ¨ âŸ¨ 0 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 âŸ© âŸ¨âŸ© âŸ©
</code></pre>
<p>We can then group the results to find the indices which are nonbalanced and balanced for each prefix:</p>
<pre><code>   {âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} "(()"
â”Œâ”€                                            
Â· âŸ¨ âŸ¨ 0 1 2 âŸ© âŸ© âŸ¨ âŸ¨ 0 âŸ© âŸ¨ 1 âŸ© âŸ© âŸ¨ âŸ¨ 0 âŸ© âŸ© âŸ¨âŸ©  
                                             â”˜
   {âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} ")()())" # Longer problem
â”Œâ”€                                                                                                              
Â· âŸ¨ âŸ¨ 0 2 4 5 âŸ© âŸ¨ 1 3 âŸ© âŸ© âŸ¨ âŸ¨ 0 2 4 âŸ© âŸ¨ 1 3 âŸ© âŸ© âŸ¨ âŸ¨ 0 2 3 âŸ© âŸ¨ 1 âŸ© âŸ© âŸ¨ âŸ¨ 0 2 âŸ© âŸ¨ 1 âŸ© âŸ© âŸ¨ âŸ¨ 0 1 âŸ© âŸ© âŸ¨ âŸ¨ 0 âŸ© âŸ© âŸ¨âŸ©  
                                                                                                               â”˜  
</code></pre>
<p>We can then of course drop the first list in each prefix so we only have the balanced indices. Iâ€™ll switch to the longer problem here so itâ€™s a little easier to see whatâ€™s happening:</p>
<pre><code>   {1â†“Â¨âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} ")()())"
â”Œâ”€                                                      
Â· âŸ¨ âŸ¨ 1 3 âŸ© âŸ© âŸ¨ âŸ¨ 1 3 âŸ© âŸ© âŸ¨ âŸ¨ 1 âŸ© âŸ© âŸ¨ âŸ¨ 1 âŸ© âŸ© âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©  
                                                       â”˜
</code></pre>
<p>We can then flatten the sublists together and find the largest element, which represents the index in a given prefix with the longest valid substring:</p>
<pre><code>   {âŒˆÂ´âŒˆÂ´Â¨âˆ¾Â¨1â†“Â¨âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} ")()())"
3
</code></pre>
<p>Because we are using 0-based indices as God intended, weâ€™ll have to add one to the result.
Weâ€™ll also take the maximum of our result and 0 in case no balanced substrings were found, which would otherwise give us <code>Â¯âˆ</code>:</p>
<pre><code>   {0âŒˆ1+âŒˆÂ´âŒˆÂ´Â¨âˆ¾Â¨1â†“Â¨âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©} ")()())"
4
</code></pre>
<p>Finally, letâ€™s look at all the test cases:</p>
<pre><code>   F â† {0âŒˆ1+âŒˆÂ´âŒˆÂ´Â¨âˆ¾Â¨1â†“Â¨âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©}
   F ")()())"
4
   F "(()"
2
   F ""
0
</code></pre>
<p>Now that weâ€™ve gone through the BQN solution, letâ€™s take a look at the CUDA and Thrust solution</p>
<h2 id="cudathrust-solution"><a class="header" href="#cudathrust-solution">CUDA/Thrust Solution</a></h2>
<p>Here is the full solution, minus some includes and using statements:</p>
<pre><code class="language-cpp">auto solve(const string&amp; problem) -&gt; int {
  const int N = problem.size();
  if (0 == N)
    return 0;

  host_vector&lt;int&gt; mapping;
  mapping.reserve(N);
  std::transform(problem.begin(), problem.end(), std::back_inserter(mapping),
                 [=](const char &amp;c) { return c == '(' ? 1 : -1; });
  device_vector&lt;int&gt; d_mapping = mapping;

  vector&lt;int&gt; starts(N - 1);
  std::iota(starts.begin(), starts.end(), 0);

  int max_len = std::accumulate(
      starts.begin(), starts.end(), 0,
      [&amp;d_mapping, N](int max_so_far, int i) {
        device_vector&lt;int&gt; prefix(N-i);
        thrust::inclusive_scan(d_mapping.begin()+i, d_mapping.end(), prefix.begin());

        device_vector&lt;int&gt; indices(N - i);
        thrust::sequence(indices.begin(), indices.end(), 0);

        auto zip_start = thrust::make_zip_iterator(
            thrust::make_tuple(prefix.begin(), indices.begin()));
        auto zip_end = thrust::make_zip_iterator(
            thrust::make_tuple(prefix.end(), indices.end()));

        int max_for_prefix = thrust::transform_reduce(
            zip_start, zip_end,
            [=] __device__(const auto &amp;tup) -&gt; int {
              return thrust::get&lt;0&gt;(tup) == 0 ? 1 + thrust::get&lt;1&gt;(tup) : 0;
            },
            0, thrust::maximum&lt;int&gt;());

        return std::max(max_so_far, max_for_prefix);
      });

  return max_len;
}

int main() {
  for (const string &amp;problem : { ")()())", "(()", "" })
    std::cout &lt;&lt; solve(problem) &lt;&lt; "\n";
  return 0;
}
</code></pre>
<p>This is quite a lot to take in, so letâ€™s break it down.</p>
<p>First I grab the problem size so I donâ€™t have to keep repeating myself, and I check to make sure our problem size is greater than zero.
I then transform the string into integers and copy the data to the GPU device.
This step is just like the bqn solution up until this point.</p>
<pre><code class="language-cpp">  const int N = problem.size();
  if (0 == N)
    return 0;

  host_vector&lt;int&gt; mapping;
  mapping.reserve(N);
  std::transform(problem.begin(), problem.end(), std::back_inserter(mapping),
                 [=](const char &amp;c) { return c == '(' ? 1 : -1; });
  device_vector&lt;int&gt; d_mapping = mapping;
</code></pre>
<p>In BQN:</p>
<pre><code>{1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©}
</code></pre>
<p>I then create an STL vector to hold the starting positions for each prefix.
Iâ€™m using the STL here instead of Thrust because Iâ€™ll otherwise have to nest my CUDA calls, and not all of the Thrust API is callable on the GPU device.
Ideally, we fit as much of our algorithm onto the GPU device to minimize any data transfer between memory spaces, but I still ended up using a mixture of the STL and Thrust.</p>
<pre><code class="language-cpp">  vector&lt;int&gt; starts(N - 1);
  std::iota(starts.begin(), starts.end(), 0);
</code></pre>
<p>Because of how the stl algorithms are used, we have to now go to the end of our
BQN solution. This call to accumulate corresponds to our outter reduction in our BQN solution here:</p>
<pre><code class="language-cpp">  // BQN) F â† {0âŒˆ1+âŒˆÂ´âŒˆÂ´Â¨âˆ¾Â¨1â†“Â¨âŠ”Â¨0=+`Â¨1-ËœÂ¨2Ã—Â¨â†“")("âŠ¸âŠ ğ•©}
  //               ^
  //              here

  int max_len = std::accumulate(
      starts.begin(), starts.end(), 0,
      [&amp;d_mapping, N](int max_so_far, int i) {
        // ...
      });
</code></pre>
<p>Weâ€™re reducing over the maximum balanced substring for each prefix of the input string.</p>
<p>Next I create a device vector for the given prefix, and take the prefix sum of the current prefix.</p>
<pre><code class="language-cpp">  // BQN) +`
  int max_len = std::accumulate(...
        device_vector&lt;int&gt; prefix(N-i);
        thrust::inclusive_scan(d_mapping.begin()+i, d_mapping.end(), prefix.begin());
</code></pre>
<p>I then create an <em>iota</em> to zip with our prefix-summed substring (or a <em>range</em> in BQN parlance, or a <em>sequence</em> in Thrust parlance (canâ€™t we all just agree on a term hereâ€¦)):</p>
<pre><code class="language-cpp">        device_vector&lt;int&gt; indices(N - i);
        thrust::sequence(indices.begin(), indices.end(), 0);

        auto zip_start = thrust::make_zip_iterator(
            thrust::make_tuple(prefix.begin(), indices.begin()));
        auto zip_end = thrust::make_zip_iterator(
            thrust::make_tuple(prefix.end(), indices.end()));        
</code></pre>
<p>This corresponds to the <em>couple</em> dyad in BQN or the <em>zip</em> function in Python and lots of functional languages.</p>
<p>I then perform two algorithms in this one step. If the given position in the prefix-summed substring is zero, that means itâ€™s balanced and I want to keep the index.
Otherwise, I can just throw it out.
After performing this transform or map algorithm, I take the max reduction of the substring to find the greatest index at which the substring is balanced.
If there are multiple points in the substring where the parens are balanced, this will find the greatest one.</p>
<pre><code class="language-cpp">        int max_for_prefix = thrust::transform_reduce(
            zip_start, zip_end,
            [=] __device__(const auto &amp;tup) -&gt; int {
              return thrust::get&lt;0&gt;(tup) == 0 ? 1 + thrust::get&lt;1&gt;(tup) : 0;
            },
            0, thrust::maximum&lt;int&gt;());
</code></pre>
<p>I then return the maximum balanced substring for the current prefix, which is then folded in the outter <code>std::accumulate</code> to find the greatest balanced substring for all prefixes in the original string.</p>
<pre><code class="language-cpp">  int max_len = std::accumulate(...
        [...](int max_so_far, int i) {
            int max_for_prefix = ...
            return std::max(max_so_far, max_for_prefix);
        });
</code></pre>
<p>I then return the maximum length I found, and we have our answer!</p>
<pre><code class="language-cpp">auto solve(const string&amp; problem) -&gt; int {
  ...
  int max_len = std::accumulate(...);
  return max_len;
}
</code></pre>
<p>I ran this with the same test cases like so:</p>
<pre><code class="language-cpp">int main() {
  for (const string &amp;problem : { ")()())", "(()", "" })
    std::cout &lt;&lt; solve(problem) &lt;&lt; "\n";
  return 0;
}
</code></pre>
<p>And running gave me:</p>
<pre><code class="language-console">$ ./src/thrust/lc-longest-valid-parens
4
2
0
</code></pre>
<p>Just like we expected!</p>
<h2 id="youtube-video-description"><a class="header" href="#youtube-video-description">YouTube Video Description</a></h2>
<p>We solve a hard leetcode problem in both BQN and CUDA C++ with the Thrust library.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Thanks for tuning in and I hope you enjoyed this example program.
You can find all the GPU examples I used in the links below.
Connor Hoekstra, if youâ€™re reading or watching this, I hope to see you out-do my BQN and CUDA solutions in another video :).</p>
<p>{% include footer.html %}</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/ashermancinelli/portable-alg-testbed">Repo for GPU Examples</a></li>
<li><a href="https://github.com/ashermancinelli/apl-snippets">Repo for BQN/APL Examples</a></li>
<li><a href="https://www.youtube.com/channel/UCZ5sL4E662VP1ZwC4h85ttQ">YouTube Channel</a></li>
<li><a href="http://www.ashermancinelli.com/">Blog</a></li>
<li><a href="https://www.linkedin.com/in/asher-mancinelli-bb4a56144/">LinkedIn</a></li>
<li><a href="https://leetcode.com/problems/longest-valid-parentheses/">LeetCode Problem</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../csblog/2021-10-19-Leetcode-And-Distributed-Computing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../coffeeblog/2023-6-11-Best-Espresso-In-Portland.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../csblog/2021-10-19-Leetcode-And-Distributed-Computing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../coffeeblog/2023-6-11-Best-Espresso-In-Portland.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
