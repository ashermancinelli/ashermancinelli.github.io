<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clang Tools for Checking Domain-Specific Errors 3/6/2021 - Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded affix "><li class="part-title">Blog</li><li class="chapter-item expanded "><a href="../csblog/2024-9-4-Debugging-In-Parallel.html">Debugging in Parallel 9/4/2024</a></li><li class="chapter-item expanded "><a href="../notes/2024-8-31-Linux-Perf-Notes.html">The Linux Perf Tool 8/31/2024</a></li><li class="chapter-item expanded "><a href="../notes/values.html">Values 8/26/2024</a></li><li class="chapter-item expanded "><a href="../notes/2024-8-30-Shell.html">Shell+Scripting 8/24/2024</a></li><li class="chapter-item expanded "><a href="../notes/editors.html">Editors+Tools 8/24/2024</a></li><li class="chapter-item expanded "><a href="../csblog/2023-6-1-C-VLA-Implementation.html">Understanding VLA 6/1/2023</a></li><li class="chapter-item expanded "><a href="../csblog/2022-5-2-BQN-reflections.html">BQN and Reflections on the Joy of Programming 5/2/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-2-2-LLVM-Development-On-NixOS.html">LLVM Development on NixOS 2/2/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-2-10-CUDA-101-Matvec.html">CUDA 101: Matrix-Vector Product 2/10/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-12-12-Compiler-Perf-Debugging.html">Debugging Performance in Compilers 12/12/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2022-1-15-Std-Expected.html">std::expected And Why It's Awesome 1/15/2022</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-7-GTest-Type-Value-Params.html">GTest Type and Value Parameterized Tests 3/7/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-6-Spack-Development-3.html">Spack for Package Development Part 3 3/6/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-6-Clang-Tools-Lambda.html" class="active">Clang Tools for Checking Domain-Specific Errors 3/6/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-5-Spack-Development-2.html">Spack for Package Development Part 2 3/5/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-3-4-Spack-Development-1.html">Spack for Package Development Part 1 3/4/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-12-23-std-mdspan-Response.html">A Look at std::mdspan 12/23/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-10-24-Popular-Languages-1965.html">Using the Most Popular Programming Languages of the '60s 10/24/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-10-19-Leetcode-And-Distributed-Computing.html">One Problem, Four Languages, Two Paradigms 10/19/2021</a></li><li class="chapter-item expanded "><a href="../csblog/2021-10-11-BQN-Cpp-CUDA.html">BQN and CUDA C++ LeetCode Solutions 10/11/2021</a></li><li class="chapter-item expanded affix "><li class="part-title">Coffee</li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-11-Best-Espresso-In-Portland.html">Best Espresso In Portland (6/11/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-22-Sterling.html">Sterling (6/22/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-Deadstock.html">Deadstock (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-22-Barista.html">Barista (6/22/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-13-Never-Coffee.html">Never Coffee (6/13/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Upper-Left-Roasters.html">Upper Left Roasters (6/15/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-Abba.html">Abba (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Rose-City-Coffee.html">Rose City Coffee (6/15/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-Sterling.html">Sterling (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-21-Superjoy.html">Superjoy (6/21/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-13-Beginners-Guide.html">Beginners Guide (6/13/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-19-Seattle-Trip-Report.html">Seattle Trip Report (6/19/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Adapt-Coffee.html">Adapt Coffee (6/15/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-13-Coava.html">Coava (6/13/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-14-PDX-Espresso-Research.html">PDX Espresso Research (6/14/2023)</a></li><li class="chapter-item expanded "><a href="../coffeeblog/2023-6-15-Nossa-Familia-Coffee.html">Nossa Familia Coffee (6/15/2023)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
layout: post
title: Clang Tools for Checking Domain-Specific Errors
permalink: /clang-lambda
cat: cs
-->
<p>Compilers are extremely proficient at catching (and even suggesting fixes for) errors in your code.
What about cases that are not formally errors, but should not exist in your codebase?
This post explores using Clang tools to address this case.</p>
<h2 id="example-use-case"><a class="header" href="#example-use-case">Example Use Case</a></h2>
<p>When using portability libraries such as <a href="https://github.com/LLNL/RAJA/blob/main/docs/sphinx/user_guide/index.rst">RAJA</a> and
<a href="https://github.com/kokkos/kokkos">Kokkos</a>, the capture clauses of lambda statements are extremely important.
When developing the open source optimization engine <a href="https://github.com/LLNL/hiop">HiOp</a> to use the portability library RAJA
in its linear algebra library,
we ran into an issue where a RAJA <code>forall</code> statement would implicitly capture the <code>this</code> pointer in an instance method
which would cause memory access errors when running on a GPU device.</p>
<p>For example, let’s say we have the following Vector class:</p>
<pre><code class="language-cpp">#include &lt;RAJA/RAJA.hpp&gt;

struct Vector {
  using namespace RAJA;
  
  Vector(std::size_t sz, int* data/*=pointer to data on device*/)
    : sz(sz), data(data) {}
    
  void times_constant(int factor) {
  
    forall&lt;cuda_exec&lt;128&gt;&gt;(RangeSegment(0, sz),
      [=] (Index_type i) {
      
        // Here, `data` is captured implicitly via `this` pointer
        // even though `this` does not reside on the GPU
        data[i] *= factor;
      });
      
  }
private:
  std::size_t sz;
  int* data;
};
</code></pre>
<p>As described in the comments above, the data lives on the device, but is accessed via the <code>this</code> pointer which does not.
The solution to this memory access error is to create a local copy of the pointer outside the scope of the RAJA lambda:</p>
<pre><code class="language-cpp">  void times_constant(int factor) {
    auto* local_data = this-&gt;data;
    forall&lt;cuda_exec&lt;128&gt;&gt;(RangeSegment(0, sz),
      [=] (Index_type i) {
        // Here, `data` is no longer captured implicitly via `this` pointer
        local_data[i] *= factor;
      });
  }
</code></pre>
<p>Of course, this is not an error that will be captured by nvcc, hipcc or another host compiler (that I know of).
At first we just examined each kernel in our codebase to ensure we did not use the <code>this</code> pointer implicitly.
Without too much effort however, we were able to develop a small tool to search our codebase for this exact case.</p>
<h2 id="clang-tools"><a class="header" href="#clang-tools">Clang Tools</a></h2>
<p>The first step in creating this tool was to set up a CMake project to link against LLVM libraries.
The directory structure looked like this:</p>
<pre><code>
lambda-checker
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    ├── driver.cpp
    └── actions.hpp

</code></pre>
<p>Quite simple, no?
<a href="https://clang.llvm.org/docs/RAVFrontendAction.html">The Clang documentation for frontend actions</a> walks through a similar task.</p>
<p><code>src/driver.cpp</code> contains all of the code to instantiate an AST Action with a clang compiler instance
(and any options you would like to give your driver), while <code>src/actions.hpp</code> contains the actual code to
traverse the AST.</p>
<h3 id="cmake"><a class="header" href="#cmake">CMake</a></h3>
<p>In the top-level CMakeLists.txt and after the usual CMake project preamble, we include relevant clang libraries:</p>
<pre><code class="language-cmake"># top-level CMakeLists.txt

find_package(Clang REQUIRED)

set(CMAKE_MODULE_PATH
  ${CMAKE_MODULE_PATH}
  "${LLVM_CMAKE_DIR}"
  )

include(AddLLVM)

include_directories(${LLVM_INCLUDE_DIRS})
include_directories(${CLANG_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})
add_definitions(${CLANG_DEFINITIONS})
</code></pre>
<p>Then, we added our plugin as a target:</p>
<pre><code class="language-cmake"># top-level CMakeLists.txt
add_executable(LambdaChecker src/driver.cpp)
target_link_libraries(LambdaChecker
  PRIVATE
  clangAST
  clangBasic
  clangFrontend
  clangSerialization
  clangTooling
  clangIndex
  clangRewrite
  clangTooling
  )
</code></pre>
<h3 id="actions"><a class="header" href="#actions">Actions</a></h3>
<p>Before we start with <code>src/actions.hpp</code>, let us first discuss strategy.
Finding a potentially dangerous lambda capture requires two predicates for each lambda function found in the AST:</p>
<ol>
<li>Does the lambda capture <code>this</code>?</li>
<li>Does the lambda dereference <code>this</code> to access a pointer or array-like member?</li>
</ol>
<p>I broke each of these steps into its own frontend action.
The first simple searches the AST for a lambda function and checks if it captures <code>this</code>:</p>
<h4 id="find-lambda-that-captures-this"><a class="header" href="#find-lambda-that-captures-this">Find Lambda that Captures <code>this</code></a></h4>
<pre><code class="language-cpp">// src/actions.hpp
class FindLambdaCaptureThis
  : public RecursiveASTVisitor&lt;FindLambdaCaptureThis&gt; {
public:
  explicit FindLambdaCaptureThis(ASTContext *Context)
    : Context(Context), MemberVisitor(Context) {}

  bool VisitLambdaExpr(LambdaExpr *Expr) {
    bool FoundThis = false;
    for (auto it = Expr-&gt;capture_begin(); it != Expr-&gt;capture_end(); it++) {
      if (it-&gt;capturesThis()) {
        FoundThis = true;
        break;
      }
    }

    /* If `this` is not captured, we don't care about it. */
    if (!FoundThis)
      return true;

    const CompoundStmt* LambdaBody = Expr-&gt;getBody();
    if (LambdaBody-&gt;body_empty())
      return true;

    for(auto Stmt : LambdaBody-&gt;body()) {
      MemberVisitor.Parent = Expr;
      MemberVisitor.TraverseStmt(Stmt);
    }

    return true;
  }

private:
  ASTContext *Context;
  FindLambdaCapturedFields MemberVisitor; // we'll come back to this
};
</code></pre>
<p>You may find that we define the function <code>VisitLambdaExpr</code> - because this is a special name registered within clang,
the compiler instance will run this function on any AST node that matches it: every lambda expression.</p>
<p>Walking through the class above, we first check if the lambda expression captures <code>this</code>:</p>
<pre><code class="language-cpp">    bool FoundThis = false;
    for (auto it = Expr-&gt;capture_begin(); it != Expr-&gt;capture_end(); it++) {
      if (it-&gt;capturesThis()) {
        FoundThis = true;
        break;
      }
    }
</code></pre>
<p>If the lambda does not capture <code>this</code>, we can continue traversing the AST:</p>
<pre><code class="language-cpp">    if (!FoundThis)
      return true;
</code></pre>
<p>Then we make another check to ensure the lambda body is not empty:</p>
<pre><code class="language-cpp">    const CompoundStmt* LambdaBody = Expr-&gt;getBody();
    if (LambdaBody-&gt;body_empty())
      return true;
</code></pre>
<p>If all the above conditions are met, we traverse the body of the lambda to find any pointer- or array-like
member variables accessed in the lambda:</p>
<pre><code class="language-cpp">    for(auto Stmt : LambdaBody-&gt;body()) {
      MemberVisitor.Parent = Expr;
      MemberVisitor.TraverseStmt(Stmt);
    }
</code></pre>
<p>Now that we have a higher-level AST traversal class to find lambdas that capture <code>this</code>, we can look at our next
AST traversal class which checks for problematic uses of member variables.
The member visitor will accept <em>all forms of expressions</em>, so we only run that visitor on the statements
in the body of the lambda.
You may also notice that we set the <code>Parent</code> field of our <code>MemberVisitor</code> - this is to improve the quality
of the diagnostics we are able to emit. We’ll expand on this later.</p>
<h4 id="member-visitor"><a class="header" href="#member-visitor">Member Visitor</a></h4>
<p>This AST visitor class ensures no pointer- or array-like member variables are accessed in the lambda</p>
<pre><code class="language-cpp">struct FindLambdaCapturedFields
  : public RecursiveASTVisitor&lt;FindLambdaCapturedFields&gt; {
public:
  explicit FindLambdaCapturedFields(ASTContext *Context)
    : Context(Context) {}

  bool VisitMemberExpr(MemberExpr *Expr) {
    auto MemberType = Expr-&gt;getType();

    /* Problematic use of member variable! Time to generate diagnostic
     * information. */
    if (MemberType-&gt;isArrayType() || MemberType-&gt;isPointerType()) {

      /* Report diagnostic information */
      clang::DiagnosticsEngine &amp;DE = Context-&gt;getDiagnostics();

      /* Error message describing the issue */
      auto ID = DE.getCustomDiagID(
          clang::DiagnosticsEngine::Error,
          "Found lambda capturing pointer-like member variable here.");
      DE.Report(Expr-&gt;getBeginLoc(), ID);

      /* Remark indicating which member variable triggered the error */
      ID = DE.getCustomDiagID(clang::DiagnosticsEngine::Note,
          "Member variable declared here:");
      DE.Report(Expr-&gt;getMemberDecl()-&gt;getBeginLoc(), ID);

      /* Remark with suggested change to mitigate the issue */
      ID = DE.getCustomDiagID(clang::DiagnosticsEngine::Remark,
          "Consider creating a local copy of the member variable in local scope"
          " just outside the lambda capture.");
      DE.Report(Parent-&gt;getBeginLoc(), ID);
    }
    return true;
  }

  ASTContext *Context;
  LambdaExpr *Parent=nullptr;
};
</code></pre>
<p>First, we check the type of the expression inside the lambda:</p>
<pre><code class="language-cpp">    auto MemberType = Expr-&gt;getType();
    /* Problematic use of member variable! Time to generate diagnostic
     * information. */
    if (MemberType-&gt;isArrayType() || MemberType-&gt;isPointerType()) {
</code></pre>
<p>If we enter this conditional, we’ve found a potential problem! Now what to do?</p>
<h4 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h4>
<p>Clang diagnostics are again a very rich library which won’t be fully flushed out here - please
consult <a href="https://clang.llvm.org/doxygen/classclang_1_1DiagnosticsEngine.html">the documentation for the Clang Diagnostics Engine</a>.</p>
<p>First order of business in emmitting diagnositcs is to get a handle for a diagnositcs engine capable
of printing helpful messages to the user of our tool.</p>
<pre><code class="language-cpp">      clang::DiagnosticsEngine &amp;DE = Context-&gt;getDiagnostics();
</code></pre>
<p>Let’s think for a moment about the sort of diagnostic we would like to emit.
I think we should report three things to the user if a lambda expression meets our
critera for an error:</p>
<ol>
<li>Location in the lambda where the member variable is used via <code>this</code> pointer</li>
<li>Location of that member’s declaration</li>
<li>Suggestion for fixing the issue</li>
</ol>
<p>Let’s address these one-by-one: first, report the location where the member variable is
potentially erroneously used.</p>
<pre><code class="language-cpp">      auto ID = DE.getCustomDiagID(
          clang::DiagnosticsEngine::Error,
          "Found lambda capturing pointer-like member variable here.");
      DE.Report(Expr-&gt;getBeginLoc(), ID);
</code></pre>
<p>Then, where the member variable was declared:</p>
<pre><code class="language-cpp">      /* Remark indicating which member variable triggered the error */
      ID = DE.getCustomDiagID(clang::DiagnosticsEngine::Note,
          "Member variable declared here:");
      DE.Report(Expr-&gt;getMemberDecl()-&gt;getBeginLoc(), ID);
</code></pre>
<p>Finally, a suggestion for fixing the error:</p>
<pre><code class="language-cpp">      /* Remark with suggested change to mitigate the issue */
      ID = DE.getCustomDiagID(clang::DiagnosticsEngine::Remark,
          "Consider creating a local copy of the member variable in local scope"
          " just outside the lambda capture.");
      DE.Report(Parent-&gt;getBeginLoc(), ID);
</code></pre>
<p>At this point, we’re essentially done - all we need is a bit of boilerplate code to
connect our AST consumer classes up to a compiler instance:</p>
<pre><code class="language-cpp">class LambdaCaptureCheckerConsumer : public clang::ASTConsumer {
public:
  explicit LambdaCaptureCheckerConsumer(ASTContext *Context)
    : Visitor(Context) {}
  explicit LambdaCaptureCheckerConsumer(CompilerInstance&amp; CI)
    : Visitor(&amp;CI.getASTContext()) {}

  virtual void HandleTranslationUnit(clang::ASTContext &amp;Context) {
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
  }
private:
  FindLambdaCaptureThis Visitor;
};
</code></pre>
<p>Now we’re done with the file <code>src/actions.hpp</code>.</p>
<h3 id="driver"><a class="header" href="#driver">Driver</a></h3>
<p>In <code>src/driver.cpp</code> we create an AST frontend action to create and use the compiler action we defined in <code>src/actions.hpp</code>:</p>
<pre><code class="language-cpp">// src/driver.cpp
class LambdaCaptureCheckerAction : public clang::ASTFrontendAction {
public:
  virtual std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(
    clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile) {
    return std::unique_ptr&lt;clang::ASTConsumer&gt;(
        new LambdaCaptureCheckerConsumer(&amp;Compiler.getASTContext()));
  }
};
</code></pre>
<p>Here I omit any command line options.
<a href="https://llvm.org/docs/CommandLine.html">The documentation on this topic</a> is rich,
so if you would like to add command line options you shouldn’t have too much trouble.</p>
<pre><code class="language-cpp">// src/driver.cpp
static cl::OptionCategory LambdaCaptureCheckerCategory("LambdaChecker options");

int main(int argc, const char **argv) {
  CommonOptionsParser Op(argc, argv, LambdaCaptureCheckerCategory);

  /* Create a new Clang Tool instance (a LibTooling environment). */
  ClangTool Tool(Op.getCompilations(), Op.getSourcePathList());

  return Tool.run(newFrontendActionFactory&lt;LambdaCaptureCheckerAction&gt;().get());
}
</code></pre>
<h3 id="running"><a class="header" href="#running">Running</a></h3>
<p>At this point, you may also generate a clang plugin library to use our AST actions
which can be loaded via compiler invocation, however I opted to stick with a standalone executable.</p>
<p>In order to fully test our AST action, I also created a subdirectory for examples,
giving us the following directory structure:</p>
<pre><code>
lambda-checker
├── CMakeLists.txt
├── src
│   ├── CMakeLists.txt
│   ├── driver.cpp
│   └── actions.hpp
└── test
    └── capture-test.cpp

</code></pre>
<p>Where <code>capture-test.cpp</code> contains:</p>
<pre><code class="language-cpp">// capture-test.cpp
struct CaptureTest {

  /* Should not capture */
  int *i;

  /* Should not capture */
  int j[1];

  /* OK to capture */
  int k=0;

  /* Method which implicitly captures `this` pointer and modifies member
   * variable `i`. This is problematic when using portability libraries, as
   * member variables may not reside on the host. */
  void methodUsingBadCapturePointer() {
    auto throwaway = [=] () {
      *i = 1;
    };
  }

  /* Raw arrays should not be used either. */
  void methodUsingBadCaptureArray() {
    auto throwaway = [=] () {
      j[0] = 1;
    };
  }

  /* The preferred method to mitigate the issue outlined above is to create a
   * local copy of the pointer and modify the underlying data through the copy.
   */
  void methodUsingGoodCapture() {
    int* localCopy = i;
    auto throwaway = [=] () {
      *localCopy += 1;
    };
  }

  /* Methods which capture `this` variables which are not pointers should not
   * cause an issue. */
  void methodNotCapturingPointer() {
    auto throwaway = [=] () {
      k++;
    };
  }
};

int main() { return 0; }
</code></pre>
<p>I added this as a CMake target such that the compile commands database would be generated for
our test case (<a href="https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html">additional documentation for compile-commands database</a>).
To do this, add the following to the top-level <code>CMakeLists.txt</code>:</p>
<pre><code class="language-cmake"># top-level CMakeLists.txt
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
add_executable(dummy-target test/capture-test.cpp)
</code></pre>
<p>This way, we are able to run our plugin driver directly on our test case.</p>
<pre><code class="language-console">
$ cd lambda-capture
$ mkdir build
$ cd build
$ cmake .. &amp;&amp; make

$ # At this point, the file `compile_commands.json` should exist in your CWD
$ # and you should be able to run the driver on our test case:
$ ./src/LambdaChecker ../test/capture-test.cpp
/path/to/lambda-capture/test/capture.cpp:17:8: error: Found lambda capturing pointer-like member variable here.

      *i = 1;
       ^
/path/to/lambda-capture/test/capture.cpp:4:3: note: Member variable declared here:
  int *i;
  ^
/path/to/lambda-capture/test/capture.cpp:16:22: remark: Consider creating a local copy of the member variable in local scope
just outside the lambda capture.
    auto throwaway = [=] () {

</code></pre>
<p>As you can see, our tool seems to be correctly identifying our domain-specific error!
After developing this tool and running it over all of our codebases which make heavy use of portability
libraries such as RAJA and Kokkos, we are confident that we have purged this error from our
codebase.</p>
<p>Hopefully this demonstration helps your team weed out nasty errors like these from your codebase as well.</p>
<p>The full code listings can be found in the <a href="https://github.com/ashermancinelli/lambda-capture-checker">repository linked here</a>.
The code snippets used here for example purposes will not map perfectly to the current repository, but should
serve as a concrete starting point.</p>
<p>{% include footer.html %}</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li><a href="https://github.com/ashermancinelli/lambda-capture-checker">Lambda Capture tool</a></li>
<li><a href="https://github.com/LLNL/RAJA/blob/main/docs/sphinx/user_guide/index.rst">RAJA</a></li>
<li><a href="https://github.com/kokkos/kokkos">Kokkos</a></li>
<li><a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">Clang compile commands database spec</a></li>
<li><a href="https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html">Clang compile commands tutorial</a></li>
<li><a href="https://github.com/LLNL/hiop">HiOp</a></li>
<li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html">Clang AST Visitor documentation</a></li>
<li><a href="https://www.youtube.com/watch?v=E6i8jmiy8MY&amp;ab_channel=CppNow">Peter Goldsborough’s C++Now talk on Clang/LLVM tools</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../csblog/2021-3-6-Spack-Development-3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../csblog/2021-3-5-Spack-Development-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../csblog/2021-3-6-Spack-Development-3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../csblog/2021-3-5-Spack-Development-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
