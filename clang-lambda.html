<!DOCTYPE html>
<html>
  <head>
    <title>Clang Tools for Checking Domain-Specific Errors – Asher Mancinelli – HPC Software Development</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Compilers are extremely proficient at catching (and even suggesting fixes for) errors in your code.
What about cases that are not formally errors, but should not exist in your codebase?
This post explores using Clang tools to address this case.

">
    <meta property="og:description" content="Compilers are extremely proficient at catching (and even suggesting fixes for) errors in your code.
What about cases that are not formally errors, but should not exist in your codebase?
This post explores using Clang tools to address this case.

">
    
    <meta name="author" content="Asher Mancinelli">

    
    <meta property="og:title" content="Clang Tools for Checking Domain-Specific Errors">
    <meta property="twitter:title" content="Clang Tools for Checking Domain-Specific Errors">
    

    <link rel="icon" href="/images/chip.png">


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="alternate" type="application/rss+xml" title="Asher Mancinelli - HPC Software Development" href="/feed.xml">

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/ashermancinelli/ashermancinelli.github.io/master/images/chip.png"></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Asher Mancinelli</a></h1>
            <p class="site-description">HPC Software Development</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Clang Tools for Checking Domain-Specific Errors</h1>

  <div class="entry">
    <p>Compilers are extremely proficient at catching (and even suggesting fixes for) errors in your code.
What about cases that are not formally errors, but should not exist in your codebase?
This post explores using Clang tools to address this case.</p>

<font size="-1">
<h4>DISCLAIMER</h4>
  <em>
    These views do not in any way represent those of Pacific Northwest National Laboratory, the US Department of Energy, Battelle, or any other organization or institution that I, Asher Mancinelli, am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="example-use-case">Example Use Case</h2>

<p>When using portability libraries such as <a href="https://github.com/LLNL/RAJA/blob/main/docs/sphinx/user_guide/index.rst">RAJA</a> and
<a href="https://github.com/kokkos/kokkos">Kokkos</a>, the capture clauses of lambda statements are extremely important.
When developing the open source optimization engine <a href="https://github.com/LLNL/hiop">HiOp</a> to use the portability library RAJA
in its linear algebra library,
we ran into an issue where a RAJA <code class="language-plaintext highlighter-rouge">forall</code> statement would implicitly capture the <code class="language-plaintext highlighter-rouge">this</code> pointer in an instance method
which would cause memory access errors when running on a GPU device.</p>

<p>For example, let’s say we have the following Vector class:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;RAJA/RAJA.hpp&gt;
</span>
<span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">RAJA</span><span class="p">;</span>
  
  <span class="n">Vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="cm">/*=pointer to data on device*/</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">sz</span><span class="p">(</span><span class="n">sz</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{}</span>
    
  <span class="kt">void</span> <span class="n">times_constant</span><span class="p">(</span><span class="kt">int</span> <span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="n">forall</span><span class="o">&lt;</span><span class="n">cuda_exec</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">RangeSegment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">),</span>
      <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">Index_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      
        <span class="c1">// Here, `data` is captured implicitly via `this` pointer</span>
        <span class="c1">// even though `this` does not reside on the GPU</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
      <span class="p">});</span>
      
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>As described in the comments above, the data lives on the device, but is accessed via the <code class="language-plaintext highlighter-rouge">this</code> pointer which does not.
The solution to this memory access error is to create a local copy of the pointer outside the scope of the RAJA lambda:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">times_constant</span><span class="p">(</span><span class="kt">int</span> <span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">local_data</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="n">forall</span><span class="o">&lt;</span><span class="n">cuda_exec</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">RangeSegment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">),</span>
      <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">Index_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Here, `data` is no longer captured implicitly via `this` pointer</span>
        <span class="n">local_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Of course, this is not an error that will be captured by nvcc, hipcc or another host compiler (that I know of).
At first we just examined each kernel in our codebase to ensure we did not use the <code class="language-plaintext highlighter-rouge">this</code> pointer implicitly.
Without too much effort however, we were able to develop a small tool to search our codebase for this exact case.</p>

<h2 id="clang-tools">Clang Tools</h2>

<p>The first step in creating this tool was to set up a CMake project to link against LLVM libraries.
The directory structure looked like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
lambda-checker
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    ├── driver.cpp
    └── actions.hpp

</code></pre></div></div>

<p>Quite simple, no?
<a href="https://clang.llvm.org/docs/RAVFrontendAction.html">The Clang documentation for frontend actions</a> walks through a similar task.</p>

<p><code class="language-plaintext highlighter-rouge">src/driver.cpp</code> contains all of the code to instantiate an AST Action with a clang compiler instance
(and any options you would like to give your driver), while <code class="language-plaintext highlighter-rouge">src/actions.hpp</code> contains the actual code to
traverse the AST.</p>

<h3 id="cmake">CMake</h3>

<p>In the top-level CMakeLists.txt and after the usual CMake project preamble, we include relevant clang libraries:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># top-level CMakeLists.txt</span>

<span class="nb">find_package</span><span class="p">(</span>Clang REQUIRED<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_MODULE_PATH
  <span class="si">${</span><span class="nv">CMAKE_MODULE_PATH</span><span class="si">}</span>
  <span class="s2">"</span><span class="si">${</span><span class="nv">LLVM_CMAKE_DIR</span><span class="si">}</span><span class="s2">"</span>
  <span class="p">)</span>

<span class="nb">include</span><span class="p">(</span>AddLLVM<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">LLVM_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CLANG_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_definitions</span><span class="p">(</span><span class="si">${</span><span class="nv">LLVM_DEFINITIONS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_definitions</span><span class="p">(</span><span class="si">${</span><span class="nv">CLANG_DEFINITIONS</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, we added our plugin as a target:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># top-level CMakeLists.txt</span>
<span class="nb">add_executable</span><span class="p">(</span>LambdaChecker src/driver.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>LambdaChecker
  PRIVATE
  clangAST
  clangBasic
  clangFrontend
  clangSerialization
  clangTooling
  clangIndex
  clangRewrite
  clangTooling
  <span class="p">)</span>
</code></pre></div></div>

<h3 id="actions">Actions</h3>

<p>Before we start with <code class="language-plaintext highlighter-rouge">src/actions.hpp</code>, let us first discuss strategy.
Finding a potentially dangerous lambda capture requires two predicates for each lambda function found in the AST:</p>

<ol>
  <li>Does the lambda capture <code class="language-plaintext highlighter-rouge">this</code>?</li>
  <li>Does the lambda dereference <code class="language-plaintext highlighter-rouge">this</code> to access a pointer or array-like member?</li>
</ol>

<p>I broke each of these steps into its own frontend action.
The first simple searches the AST for a lambda function and checks if it captures <code class="language-plaintext highlighter-rouge">this</code>:</p>

<h4 id="find-lambda-that-captures-this">Find Lambda that Captures <code class="language-plaintext highlighter-rouge">this</code>
</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/actions.hpp</span>
<span class="k">class</span> <span class="nc">FindLambdaCaptureThis</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">RecursiveASTVisitor</span><span class="o">&lt;</span><span class="n">FindLambdaCaptureThis</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">FindLambdaCaptureThis</span><span class="p">(</span><span class="n">ASTContext</span> <span class="o">*</span><span class="n">Context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Context</span><span class="p">(</span><span class="n">Context</span><span class="p">),</span> <span class="n">MemberVisitor</span><span class="p">(</span><span class="n">Context</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">VisitLambdaExpr</span><span class="p">(</span><span class="n">LambdaExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">FoundThis</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">capture_begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">capture_end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">capturesThis</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">FoundThis</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* If `this` is not captured, we don't care about it. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FoundThis</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CompoundStmt</span><span class="o">*</span> <span class="n">LambdaBody</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getBody</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LambdaBody</span><span class="o">-&gt;</span><span class="n">body_empty</span><span class="p">())</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">Stmt</span> <span class="o">:</span> <span class="n">LambdaBody</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">MemberVisitor</span><span class="p">.</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">Expr</span><span class="p">;</span>
      <span class="n">MemberVisitor</span><span class="p">.</span><span class="n">TraverseStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">ASTContext</span> <span class="o">*</span><span class="n">Context</span><span class="p">;</span>
  <span class="n">FindLambdaCapturedFields</span> <span class="n">MemberVisitor</span><span class="p">;</span> <span class="c1">// we'll come back to this</span>
<span class="p">};</span>
</code></pre></div></div>

<p>You may find that we define the function <code class="language-plaintext highlighter-rouge">VisitLambdaExpr</code> - because this is a special name registered within clang,
the compiler instance will run this function on any AST node that matches it: every lambda expression.</p>

<p>Walking through the class above, we first check if the lambda expression captures <code class="language-plaintext highlighter-rouge">this</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">bool</span> <span class="n">FoundThis</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">capture_begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">capture_end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">capturesThis</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">FoundThis</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>If the lambda does not capture <code class="language-plaintext highlighter-rouge">this</code>, we can continue traversing the AST:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FoundThis</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>

<p>Then we make another check to ensure the lambda body is not empty:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">const</span> <span class="n">CompoundStmt</span><span class="o">*</span> <span class="n">LambdaBody</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getBody</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LambdaBody</span><span class="o">-&gt;</span><span class="n">body_empty</span><span class="p">())</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>

<p>If all the above conditions are met, we traverse the body of the lambda to find any pointer- or array-like
member variables accessed in the lambda:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">Stmt</span> <span class="o">:</span> <span class="n">LambdaBody</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">MemberVisitor</span><span class="p">.</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">Expr</span><span class="p">;</span>
      <span class="n">MemberVisitor</span><span class="p">.</span><span class="n">TraverseStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Now that we have a higher-level AST traversal class to find lambdas that capture <code class="language-plaintext highlighter-rouge">this</code>, we can look at our next
AST traversal class which checks for problematic uses of member variables.
The member visitor will accept <em>all forms of expressions</em>, so we only run that visitor on the statements
in the body of the lambda.
You may also notice that we set the <code class="language-plaintext highlighter-rouge">Parent</code> field of our <code class="language-plaintext highlighter-rouge">MemberVisitor</code> - this is to improve the quality
of the diagnostics we are able to emit. We’ll expand on this later.</p>

<h4 id="member-visitor">Member Visitor</h4>

<p>This AST visitor class ensures no pointer- or array-like member variables are accessed in the lambda</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">FindLambdaCapturedFields</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">RecursiveASTVisitor</span><span class="o">&lt;</span><span class="n">FindLambdaCapturedFields</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">FindLambdaCapturedFields</span><span class="p">(</span><span class="n">ASTContext</span> <span class="o">*</span><span class="n">Context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Context</span><span class="p">(</span><span class="n">Context</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">VisitMemberExpr</span><span class="p">(</span><span class="n">MemberExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">MemberType</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">();</span>

    <span class="cm">/* Problematic use of member variable! Time to generate diagnostic
     * information. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MemberType</span><span class="o">-&gt;</span><span class="n">isArrayType</span><span class="p">()</span> <span class="o">||</span> <span class="n">MemberType</span><span class="o">-&gt;</span><span class="n">isPointerType</span><span class="p">())</span> <span class="p">{</span>

      <span class="cm">/* Report diagnostic information */</span>
      <span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">DE</span> <span class="o">=</span> <span class="n">Context</span><span class="o">-&gt;</span><span class="n">getDiagnostics</span><span class="p">();</span>

      <span class="cm">/* Error message describing the issue */</span>
      <span class="k">auto</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">DE</span><span class="p">.</span><span class="n">getCustomDiagID</span><span class="p">(</span>
          <span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span>
          <span class="s">"Found lambda capturing pointer-like member variable here."</span><span class="p">);</span>
      <span class="n">DE</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getBeginLoc</span><span class="p">(),</span> <span class="n">ID</span><span class="p">);</span>

      <span class="cm">/* Remark indicating which member variable triggered the error */</span>
      <span class="n">ID</span> <span class="o">=</span> <span class="n">DE</span><span class="p">.</span><span class="n">getCustomDiagID</span><span class="p">(</span><span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span><span class="o">::</span><span class="n">Note</span><span class="p">,</span>
          <span class="s">"Member variable declared here:"</span><span class="p">);</span>
      <span class="n">DE</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getMemberDecl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getBeginLoc</span><span class="p">(),</span> <span class="n">ID</span><span class="p">);</span>

      <span class="cm">/* Remark with suggested change to mitigate the issue */</span>
      <span class="n">ID</span> <span class="o">=</span> <span class="n">DE</span><span class="p">.</span><span class="n">getCustomDiagID</span><span class="p">(</span><span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span><span class="o">::</span><span class="n">Remark</span><span class="p">,</span>
          <span class="s">"Consider creating a local copy of the member variable in local scope"</span>
          <span class="s">" just outside the lambda capture."</span><span class="p">);</span>
      <span class="n">DE</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">getBeginLoc</span><span class="p">(),</span> <span class="n">ID</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">ASTContext</span> <span class="o">*</span><span class="n">Context</span><span class="p">;</span>
  <span class="n">LambdaExpr</span> <span class="o">*</span><span class="n">Parent</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>First, we check the type of the expression inside the lambda:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">auto</span> <span class="n">MemberType</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">();</span>
    <span class="cm">/* Problematic use of member variable! Time to generate diagnostic
     * information. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MemberType</span><span class="o">-&gt;</span><span class="n">isArrayType</span><span class="p">()</span> <span class="o">||</span> <span class="n">MemberType</span><span class="o">-&gt;</span><span class="n">isPointerType</span><span class="p">())</span> <span class="p">{</span>
</code></pre></div></div>

<p>If we enter this conditional, we’ve found a potential problem! Now what to do?</p>

<h4 id="diagnostics">Diagnostics</h4>

<p>Clang diagnostics are again a very rich library which won’t be fully flushed out here - please
consult <a href="https://clang.llvm.org/doxygen/classclang_1_1DiagnosticsEngine.html">the documentation for the Clang Diagnostics Engine</a>.</p>

<p>First order of business in emmitting diagnositcs is to get a handle for a diagnositcs engine capable
of printing helpful messages to the user of our tool.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">DE</span> <span class="o">=</span> <span class="n">Context</span><span class="o">-&gt;</span><span class="n">getDiagnostics</span><span class="p">();</span>
</code></pre></div></div>

<p>Let’s think for a moment about the sort of diagnostic we would like to emit.
I think we should report three things to the user if a lambda expression meets our 
critera for an error:</p>

<ol>
  <li>Location in the lambda where the member variable is used via <code class="language-plaintext highlighter-rouge">this</code> pointer</li>
  <li>Location of that member’s declaration</li>
  <li>Suggestion for fixing the issue</li>
</ol>

<p>Let’s address these one-by-one: first, report the location where the member variable is
potentially erroneously used.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">auto</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">DE</span><span class="p">.</span><span class="n">getCustomDiagID</span><span class="p">(</span>
          <span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span>
          <span class="s">"Found lambda capturing pointer-like member variable here."</span><span class="p">);</span>
      <span class="n">DE</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getBeginLoc</span><span class="p">(),</span> <span class="n">ID</span><span class="p">);</span>
</code></pre></div></div>

<p>Then, where the member variable was declared:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="cm">/* Remark indicating which member variable triggered the error */</span>
      <span class="n">ID</span> <span class="o">=</span> <span class="n">DE</span><span class="p">.</span><span class="n">getCustomDiagID</span><span class="p">(</span><span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span><span class="o">::</span><span class="n">Note</span><span class="p">,</span>
          <span class="s">"Member variable declared here:"</span><span class="p">);</span>
      <span class="n">DE</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getMemberDecl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getBeginLoc</span><span class="p">(),</span> <span class="n">ID</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, a suggestion for fixing the error:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="cm">/* Remark with suggested change to mitigate the issue */</span>
      <span class="n">ID</span> <span class="o">=</span> <span class="n">DE</span><span class="p">.</span><span class="n">getCustomDiagID</span><span class="p">(</span><span class="n">clang</span><span class="o">::</span><span class="n">DiagnosticsEngine</span><span class="o">::</span><span class="n">Remark</span><span class="p">,</span>
          <span class="s">"Consider creating a local copy of the member variable in local scope"</span>
          <span class="s">" just outside the lambda capture."</span><span class="p">);</span>
      <span class="n">DE</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">getBeginLoc</span><span class="p">(),</span> <span class="n">ID</span><span class="p">);</span>
</code></pre></div></div>

<p>At this point, we’re essentially done - all we need is a bit of boilerplate code to
connect our AST consumer classes up to a compiler instance:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LambdaCaptureCheckerConsumer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">clang</span><span class="o">::</span><span class="n">ASTConsumer</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">LambdaCaptureCheckerConsumer</span><span class="p">(</span><span class="n">ASTContext</span> <span class="o">*</span><span class="n">Context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Visitor</span><span class="p">(</span><span class="n">Context</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="n">LambdaCaptureCheckerConsumer</span><span class="p">(</span><span class="n">CompilerInstance</span><span class="o">&amp;</span> <span class="n">CI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Visitor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CI</span><span class="p">.</span><span class="n">getASTContext</span><span class="p">())</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">HandleTranslationUnit</span><span class="p">(</span><span class="n">clang</span><span class="o">::</span><span class="n">ASTContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Visitor</span><span class="p">.</span><span class="n">TraverseDecl</span><span class="p">(</span><span class="n">Context</span><span class="p">.</span><span class="n">getTranslationUnitDecl</span><span class="p">());</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="n">FindLambdaCaptureThis</span> <span class="n">Visitor</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Now we’re done with the file <code class="language-plaintext highlighter-rouge">src/actions.hpp</code>.</p>

<h3 id="driver">Driver</h3>

<p>In <code class="language-plaintext highlighter-rouge">src/driver.cpp</code> we create an AST frontend action to create and use the compiler action we defined in <code class="language-plaintext highlighter-rouge">src/actions.hpp</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/driver.cpp</span>
<span class="k">class</span> <span class="nc">LambdaCaptureCheckerAction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">clang</span><span class="o">::</span><span class="n">ASTFrontendAction</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">clang</span><span class="o">::</span><span class="n">ASTConsumer</span><span class="o">&gt;</span> <span class="n">CreateASTConsumer</span><span class="p">(</span>
    <span class="n">clang</span><span class="o">::</span><span class="n">CompilerInstance</span> <span class="o">&amp;</span><span class="n">Compiler</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span> <span class="n">InFile</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">clang</span><span class="o">::</span><span class="n">ASTConsumer</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">LambdaCaptureCheckerConsumer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Compiler</span><span class="p">.</span><span class="n">getASTContext</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here I omit any command line options.
<a href="https://llvm.org/docs/CommandLine.html">The documentation on this topic</a> is rich,
so if you would like to add command line options you shouldn’t have too much trouble.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/driver.cpp</span>
<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">OptionCategory</span> <span class="nf">LambdaCaptureCheckerCategory</span><span class="p">(</span><span class="s">"LambdaChecker options"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CommonOptionsParser</span> <span class="n">Op</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">LambdaCaptureCheckerCategory</span><span class="p">);</span>

  <span class="cm">/* Create a new Clang Tool instance (a LibTooling environment). */</span>
  <span class="n">ClangTool</span> <span class="n">Tool</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getCompilations</span><span class="p">(),</span> <span class="n">Op</span><span class="p">.</span><span class="n">getSourcePathList</span><span class="p">());</span>

  <span class="k">return</span> <span class="n">Tool</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">newFrontendActionFactory</span><span class="o">&lt;</span><span class="n">LambdaCaptureCheckerAction</span><span class="o">&gt;</span><span class="p">().</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="running">Running</h3>

<p>At this point, you may also generate a clang plugin library to use our AST actions
which can be loaded via compiler invocation, however I opted to stick with a standalone executable.</p>

<p>In order to fully test our AST action, I also created a subdirectory for examples,
giving us the following directory structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
lambda-checker
├── CMakeLists.txt
├── src
│   ├── CMakeLists.txt
│   ├── driver.cpp
│   └── actions.hpp
└── test
    └── capture-test.cpp

</code></pre></div></div>

<p>Where <code class="language-plaintext highlighter-rouge">capture-test.cpp</code> contains:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// capture-test.cpp</span>
<span class="k">struct</span> <span class="nc">CaptureTest</span> <span class="p">{</span>

  <span class="cm">/* Should not capture */</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

  <span class="cm">/* Should not capture */</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="cm">/* OK to capture */</span>
  <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* Method which implicitly captures `this` pointer and modifies member
   * variable `i`. This is problematic when using portability libraries, as
   * member variables may not reside on the host. */</span>
  <span class="kt">void</span> <span class="n">methodUsingBadCapturePointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">throwaway</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="cm">/* Raw arrays should not be used either. */</span>
  <span class="kt">void</span> <span class="n">methodUsingBadCaptureArray</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">throwaway</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
      <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="cm">/* The preferred method to mitigate the issue outlined above is to create a
   * local copy of the pointer and modify the underlying data through the copy.
   */</span>
  <span class="kt">void</span> <span class="n">methodUsingGoodCapture</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">localCopy</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">throwaway</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">localCopy</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="cm">/* Methods which capture `this` variables which are not pointers should not
   * cause an issue. */</span>
  <span class="kt">void</span> <span class="n">methodNotCapturingPointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">throwaway</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
      <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>I added this as a CMake target such that the compile commands database would be generated for
our test case (<a href="https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html">additional documentation for compile-commands database</a>).
To do this, add the following to the top-level <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># top-level CMakeLists.txt</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_EXPORT_COMPILE_COMMANDS ON<span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>dummy-target test/capture-test.cpp<span class="p">)</span>
</code></pre></div></div>

<p>This way, we are able to run our plugin driver directly on our test case.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>lambda-capture
<span class="gp">$</span><span class="w"> </span><span class="nb">mkdir </span>build
<span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>build
<span class="gp">$</span><span class="w"> </span>cmake .. <span class="o">&amp;&amp;</span> make
<span class="go">
</span><span class="gp">$</span><span class="w"> </span><span class="c"># At this point, the file `compile_commands.json` should exist in your CWD</span>
<span class="gp">$</span><span class="w"> </span><span class="c"># and you should be able to run the driver on our test case:</span>
<span class="gp">$</span><span class="w"> </span>./src/LambdaChecker ../test/capture-test.cpp
<span class="go">/path/to/lambda-capture/test/capture.cpp\:17\:8: error: Found lambda capturing pointer-like member variable here.

</span><span class="gp">      *i = 1;</span><span class="w">
</span><span class="go">       ^
/path/to/lambda-capture/test/capture.cpp\:4\:3: note: Member variable declared here:
</span><span class="gp">  int *i;</span><span class="w">
</span><span class="go">  ^
/path/to/lambda-capture/test/capture.cpp\:16\:22: remark: Consider creating a local copy of the member variable in local scope
just outside the lambda capture.
    auto throwaway = [=] () {

</span></code></pre></div></div>

<p>As you can see, our tool seems to be correctly identifying our domain-specific error!
After developing this tool and running it over all of our codebases which make heavy use of portability
libraries such as RAJA and Kokkos, we are confident that we have purged this error from our
codebase.</p>

<p>Hopefully this demonstration helps your team weed out nasty errors like these from your codebase as well.</p>

<p>The full code listings can be found in the <a href="https://github.com/ashermancinelli/lambda-capture-checker">repository linked here</a>.
The code snippets used here for example purposes will not map perfectly to the current repository, but should
serve as a concrete starting point.</p>

<h2> Contact </h2>

<p>You can reach me at any of the links below:</p>

<ul>
  <li><a target="_blank" href="https://www.youtube.com/c/AsherMancinelli">YouTube</a></li>
  <li><a target="_blank" href="https://www.linkedin.com/in/asher-mancinelli-bb4a56144/">LinkedIn</a></li>
  <li><a target="_blank" href="https://github.com/ashermancinelli">GitHub</a></li>
  <li><a target="_blank" href="mailto:ashermancinelli@gmail.com">Personal Email</a></li>
</ul>

<font size="-1">
<h4>DISCLAIMER</h4>
  <em>
    These views do not in any way represent those of Pacific Northwest National Laboratory, the US Department of Energy, Battelle, or any other organization or institution that I, Asher Mancinelli, am professionally associated with.
    These views are entirely my own.
  </em>
</font>

<h2 id="references">References</h2>

<ol>
  <li><a href="https://github.com/ashermancinelli/lambda-capture-checker">Lambda Capture tool</a></li>
  <li><a href="https://github.com/LLNL/RAJA/blob/main/docs/sphinx/user_guide/index.rst">RAJA</a></li>
  <li><a href="https://github.com/kokkos/kokkos">Kokkos</a></li>
  <li><a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">Clang compile commands database spec</a></li>
  <li><a href="https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html">Clang compile commands tutorial</a></li>
  <li><a href="https://github.com/LLNL/hiop">HiOp</a></li>
  <li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html">Clang AST Visitor documentation</a></li>
  <li><a href="https://www.youtube.com/watch?v=E6i8jmiy8MY&ab_channel=CppNow">Peter Goldsborough’s C++Now talk on Clang/LLVM tools</a></li>
</ol>

  </div>

  <div class="date">
    Written on March  6, 2021
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:ashermancinelli@gmail.com"><i class="svg-icon email"></i></a>


<a href="https://github.com/ashermancinelli"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/https://www.linkedin.com/in/asher-mancinelli-bb4a56144/"><i class="svg-icon linkedin"></i></a>




<a href="https://youtube.com/channel/UCZ5sL4E662VP1ZwC4h85ttQ"><i class="svg-icon youtube"></i></a>

        </footer>
      </div>
    </div>
    
    <div>Icons made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
</div>
    
    

  </body>
</html>
